from openalea.plantgl.all import * 
from openalea.mtg.io import *
from openalea.mtg.aml import *
from openalea.mtg.mtg import *
import random
import itertools
from math import *
import numpy as np
import time as t
import csv
from copy import *
#import IOxls
import os
import pandas as pd


##### Configuration du chemin #####
INPUTS_DIRPATH = 'inputs'
OUTPUTS_DIRPATH = 'outputs'
GRAPHS_DIRPATH = 'graphs'

##### Parametres plante #####
path_param=os.path.join(INPUTS_DIRPATH,'Parametre_plante_Lgrass.xls') # Fichier contenant les parametres
onglet1='FL'
onglet2='FC'
#paramP1=IOxls.read_plant_param(path_param, onglet1) # Lecture du premier onglet
#paramP2=IOxls.read_plant_param(path_param, onglet2)
#paramManagement=IOxls.read_plant_param(path_param, 'Management')

TableParamP1=pd.read_excel(path_param, sheet_name=onglet1)
TableParamP2=pd.read_excel(path_param, sheet_name=onglet2)
paramP1=dict(zip(TableParamP1['name'],TableParamP1['value']))
paramP2=dict(zip(TableParamP2['name'],TableParamP2['value']))

TableManagement=pd.read_excel(path_param,sheet_name='Management')
paramManagement=dict(zip(TableManagement['name'],TableManagement['value']))
ParamP=[paramP2] #liste des parametres plante
nb_plantes=len(ParamP)

num_pointe=0
num_primordium=0


LSTEP=1
DureeExp = 500

##### Parametre scene #####
OptionRacine='SansRacines' 
#OptionRacine='AvecRacines'

Densite=400 #en nb de plante par m2
Espacement=10*sqrt(10000/Densite) #en mm
NBlignes=int(ceil(sqrt(nb_plantes)))
NBcolonnes=int(floor(sqrt(nb_plantes)))
posPlante=[[i,j] for i,j in zip(sorted(list(range(NBlignes))*NBcolonnes),list(range(NBcolonnes))*NBlignes)]
genotype=[0]

##### Definition des contours pour la sortie graphique #####
limbo=profilelimbe.deepcopy()
foldlimbo=profilefoldlimbe.deepcopy()
gaino=profilegaine.deepcopy()

##### Parametres coupe #####
groupe='croissance' # Permet de realiser les coupes
reprise_coupe=False
#CoupeTaille=600000.

# Default name of the output
output_induction_file_name = 'output_induction'
output_organ_lengths_file_name = 'output_organ_lengths'



##### Maitrise de l'aleatoire #####
seed=0
random.seed(seed)

##### Activation du tallage
option_tallage = True

##### Activation de la senescence
option_senescence = True


##### Activation de la floraison #####
option_floraison = False        # True or False

##### Activation caribu #####
option_caribu = False   # l appel de caribu n est pas encore implemente dans lgrass

##### Activation axiom existant #####
OptionAxiom=False  #Ajout Thibault 02/06/2020 partir d'un axiom deja existant

##### Nom de la simulation #####
name_sim = "Simulation"

##### Activation sorties graphiques
option_graphic_outputs = True


#### Load flowering model
from lgrass import flowering_functions
flowering_model = flowering_functions.FloweringFunctions()


# ------------------------------------------------------------------------------------------------
# -------------------------------- Meteorological data -------------------------------------------
# ------------------------------------------------------------------------------------------------
# Import of meteorological data from a .csv file with separator ';'
# Column names should be:
#   - doy: integer (1 = 01/01)
#   - date: YYYY_MM_DD
#   - mean_temperature: float
#   - daylength: float
# ------------------------------------------------------------------------------------------------

from lgrass import meteo_ephem
sowing_date = "2018_11_13"
site = 'LUSIGNAN'
meteo_path = os.path.join(INPUTS_DIRPATH, 'meteo_controlled_conditions.csv')


# ------------------------------------------------------------------------------------------------
# -------------------------------------------- Coupe ---------------------------------------------
# ------------------------------------------------------------------------------------------------
cutting_dates = []
changing_day_cutting = True # Allow that cutting occurs only once in a day (the first GDD)


#########   Definition Plante   #########
scales={}
parameters={}

scales['CouvertVegetal']=1
parameters['CouvertVegetal']=[]

class ParamPlante:
  def __init__(self,id_plante=0,id_geno=0):
    self.id_plante=id_plante
    self.id_geno=id_geno
  
scales['Plante']=2
parameters['Plante']=['ParamPlante']


class ParamPhytomere:
  def __init__(self, id_plante=0, id_talle=0, id_rang=1, topology=(0,), age=0, angletal=0, organ_lengths={}):#, Carbdescend=0, Carbmonte=0):
    self.id_plante=id_plante
    self.id_talle=id_talle
    self.id_rang=id_rang
    self.topology=topology     # Topological information
    self.age=age
    self.angletal=angletal
    self.organ_lengths=organ_lengths
#    self.Carbdescend=Carbdescend
#    self.Carbmonte=Carbmonte
scales['phytomere']=3
parameters['phytomere']=['ParamPhytomere']

scales['Entrenoeud']=4
parameters['Entrenoeud']=[]



class ParamFeuille:
  def __init__(self,age=0, Agecroiss=0, Taillefeuille=0, id_plante=0, id_talle=0, id_rang=1, topology=(0,), Ymax=0, Difftps=0,  Taillefinalelimbe=0, Taillefinalegaine=0., Taillelimbe=0, Taillegaine=0, Phase='cachee', rapportK=0.2, coupe=0.,Cutstatus='intact', angleinsert=0,angletal=0., id_geno=0, surface_limbe=0, surface_gaine=0, biomass=0., Besoinencroiss=0,TailleEmergence=0.,R=0.973):
    self.age=age                             # Age de la feuille
    self.Agecroiss=Agecroiss                 # 
    self.Taillefeuille=Taillefeuille         # Taille de la feuille au temps t
    self.id_plante=id_plante                 # Identifiant de la plante (compris entre 0 et nb_plantes)
    self.id_talle=id_talle                   # Identifiant de la talle
    self.id_rang=id_rang                     # Rang de la feuille
    self.topology=topology                   # Topological information
    self.Ymax=Ymax                           # Taille finale de la feuille
    self.Difftps=Difftps                     # Delai entre l'apparition de 2 feuilles
    self.Taillefinalelimbe=Taillefinalelimbe # Taille finale du limbe
    self.Taillefinalegaine=Taillefinalegaine # Taille finale de la gaine
    self.Taillelimbe=Taillelimbe             # Taille du limbe au temps t
    self.Taillegaine=Taillegaine             # Taille de la gaine au temps t
    self.Phase=Phase                         # Stade de la feuille : cachee, visible, 0 0
    self.rapportK=rapportK                   # Rapport gaine/feuille
    self.coupe=coupe                         # Longueur de coupe
    self.Cutstatus=Cutstatus                 # Quantite de coupe : intact, partiellementcoupee(=feuille coupee et gaine intacte), entierementcoupee(=feuille et gaine coupee)
    self.angleinsert=angleinsert             # Angle limbe
    self.angletal=angletal                   # Angle de la talle qui ecarte la feuille
    self.id_geno=id_geno
    self.surface_limbe=surface_limbe         # Surface limbe (mm2)
    self.surface_gaine=surface_gaine         # Surface gaine (mm2)
    self.biomass=biomass
    self.Besoinencroiss=Besoinencroiss
    self.TailleEmergence=TailleEmergence
    self.R=R
scales['Feuille']=4
parameters['Feuille']=['ParamFeuille']

class ParamSegFeuille:
  def __init__(self,id_plante, id_talle, id_rang, idLong,hauteur):
    self.id_plante=id_plante
    self.id_talle=id_talle
    self.id_rang=id_rang
    self.idLong=idLong
    self.hauteur=hauteur
scales['SegFeuille']=5
parameters['SegFeuille']=['ParamSegFeuille']

class ParamEntrenoeud:
  def __init__(self, id_plante, id_talle, id_rang=1, topology=(0,), internode_type='short_internode', length=0, width=2, final_length=10):
    self.id_plante = id_plante                    # Id of the plant (between 0 and number of plants-1) 
    self.id_talle = id_talle                      # Id of the tiller
    self.id_rang = id_rang                        # Rank of the phytomere
    self.topology=topology                        # Topological information
    self.internode_type = internode_type          # Type of the internode mean : short_internode or long_internode
    self.length = length                          # Current length of the internode when time = t
    self.width = width                            # Width of the internode, constant
    self.final_length = final_length              # Final length of the internode (function of the sheath of the previous phytomere)
scales['Entrenoeud']=4
parameters['Entrenoeud']=['ParamEntrenoeud']

class ParamApex:
  def __init__(self, id_plante, id_talle, id_rang=1, topology=(0,), retard=0, total_emerged_leaves=0, total_created_leaves=0, day=0, primary_induction_index=0, secondary_induction_index=0, phenological_state='vegetative', primordia_number=3, spikelet_created=0, final_leaf_number=None, final_spikelet_number=None, organ_lengths_dict={}, terminal_spikelet_height=0, heading_date=None, appearance_date=None, id_geno=0):   # PARAMETRE
    self.id_plante = id_plante
    self.id_talle = id_talle
    self.id_rang = id_rang
    self.topology=topology                        # Topological information
    self.retard = retard
    self.total_emerged_leaves = total_emerged_leaves
    self.total_created_leaves = total_created_leaves                         # number of leaves produced by the apex
    self.day = day
    self.primary_induction_index = primary_induction_index
    self.secondary_induction_index = secondary_induction_index
    self.phenological_state = phenological_state        # Phenological state of the apex. Values : vegetative, reproductive, dead
    self.primordia_number = primordia_number
    self.spikelet_created = spikelet_created
    self.final_leaf_number = final_leaf_number
    self.final_spikelet_number = final_spikelet_number
    self.organ_lengths_dict = organ_lengths_dict
    self.terminal_spikelet_height = terminal_spikelet_height
    self.heading_date = heading_date
    self.appearance_date = appearance_date
    self.id_geno=id_geno
    
scales['apex']=4
parameters['apex']=['ParamApex']

class ParamApexTal:
  def __init__(self, id_plante, id_talle=0, id_rang=1, topology=(0,), retard=0, day=0, primary_induction_index=0, secondary_induction_index=0, phenological_state='vegetative', id_geno=0):
    self.id_plante=id_plante
    self.id_talle=id_talle
    self.id_rang=id_rang
    self.topology=topology                        # Topological information
    self.retard=retard
    self.day = day
    self.primary_induction_index = primary_induction_index
    self.secondary_induction_index = secondary_induction_index
    self.phenological_state = phenological_state        # Phenological state of the apex. Values : vegetative, reproductive, dead
    self.id_geno=id_geno
    
scales['ApexTal']=4
parameters['ApexTal']=['ParamApexTal']

class ParamEntrenoeudEpi:
  def __init__(self, id_plante, id_talle, id_rang, topology=(0,), long_entrenoeud=0):
    self.id_plante=id_plante
    self.id_talle=id_talle
    self.id_rang=id_rang
    self.topology=topology                        # Topological information
    self.long_entrenoeud = long_entrenoeud      # Longueur moyenne des entrenoeuds (entre chaque insertion d epillet)
scales['EntrenoeudEpi']=5
parameters['EntrenoeudEpi']=['ParamEntrenoeudEpi']

class ParamEpillet:
  def __init__(self, id_plante, id_talle, id_rang, topology=(0,), long_epillet=0):
    self.id_plante=id_plante
    self.id_talle=id_talle
    self.id_rang=id_rang
    self.topology=topology                        # Topological information
    self.long_epillet = long_epillet            # Longueur moyenne des epillets
scales['Epillet']=5
parameters['Epillet']=['ParamEpillet']

class ParambourgeonRoot:
  def __init__(self,id_plante, id_talle=0, id_rang=1, nb_prod_root=0, id_geno=0):
    self.id_plante=id_plante
    self.id_talle=id_talle
    self.id_rang=id_rang
    self.nb_prod_root=nb_prod_root
    self.id_geno=id_geno
scales['bourgeonRoot']=4
parameters['bourgeonRoot']=['ParambourgeonRoot']

class ParamRacine:
  def __init__(self,age=0, id_plante=0, id_talle=0 ,id_rang=0, axe_arret=0, lateral_arret=0, feuil_ref=0):
    self.age=age
    self.id_plante=id_plante
    self.id_talle=id_talle
    self.id_rang=id_rang
    self.axe_arret=axe_arret
    self.lateral_arret=lateral_arret
    self.feuil_ref=feuil_ref
scales['racine']=4
parameters['racine']=['ParamRacine']

class pte:
  def __init__(self, id_pointe=0,id_plante=0, age=0, diametre=0., distPrimInit=0., longueur=0.01, profondeur=0.,dateDerniereCreation=0, posO=np.array([0.,0.,0.]),Tortue=np.array([[0.,0.,-1.],[0.,1.,0],[-1.,0.,0.]]), isaxe=False,arretee=False, senile=False,axe_mort=False,segment=0):
    self.id_pointe=id_pointe
    self.id_plante=id_plante
    self.age=age
    self.diametre=diametre
    self.distPrimInit=distPrimInit
    self.longueur=longueur
    self.profondeur=profondeur
    self.dateDerniereCreation=dateDerniereCreation
    self.posO=posO                                  # Position de la pointe dans l'espace
    self.Tortue=Tortue
    self.isaxe=isaxe
    self.arretee=arretee                            # 
    self.senile=senile                              # Etat de senescence de la pointe
    self.axe_mort=axe_mort
    self.segment=segment
scales['tip']=5
parameters['tip']=['pte']

class primord:
  def __init__(self, id_plante,id_primord,age,diametre,Tortue=np.array([[0.,0.,-1],[0.,1,0],[-1.,0.,0.]]),avorte=False,id_pointe_axe=0,posO=np.array([0.,0.,0.])):
    self.id_plante=id_plante
    self.id_primord=id_primord
    self.age=age
    self.diametre=diametre
    self.Tortue=Tortue
    self.avorte=avorte
    self.id_pointe_axe=id_pointe_axe
    self.posO=posO
scales['Site']=5
parameters['Site']=['primord']

class seg:
  def __init__(self, jourForm, diametre, longueur=0., id_pointe_axe=0):
    self.jourForm=jourForm
    self.diametre=diametre
    self.longueur=longueur
    self.id_pointe_axe=id_pointe_axe
scales['segment']=5
parameters['segment']=['seg']

#########   definition sol   #########
path_sol=os.path.join(INPUTS_DIRPATH, 'sol2.txt')
fichier_sol=open(path_sol, "r")
tableau_sol=csv.reader(fichier_sol, delimiter='	')
Sol=[]
j=0
for x in tableau_sol:
  if j==0:
    j=1
  else:
    Sol.append(x)
fichier_sol.close()

class Horizon:# Horizon de sol
  def __init__(self,croiss,ramif,iCMeca,oCMeca):
    self.croiss  # Coefficient de croissance, compris entre 0 et 1
    self.ramif   # Coefficient multiplicateur de distance inter-ramif
    self.iCMeca  # Intensite de la contrainte mecanique
    self.oCMeca  # Orientation de la contrainte mecanique (O iso, ou 1 vert)




module CouvertVegetal : scale=1
module Plante(ParamPlante) : scale=2
module phytomere(ParamPhytomere, ParamApex) : scale=3
module Entrenoeud(ParamEntrenoeud, ParamApex, ParamFeuille, ParamPhytomere) : scale=4
module Feuille(ParamFeuille, ParamApex, ParamPhytomere) : scale=4
module SegFeuille(ParamSegFeuille) : scale=5
module apex(ParamApex) : scale=4
module ApexTal(ParamApexTal) : scale=4
module EntrenoeudEpi(ParamEntrenoeudEpi, ParamApex) : scale = 5
module Epillet(ParamEpillet, ParamApex) : scale = 5
module bourgeonRoot(ParambourgeonRoot, ParamEntrenoeud) : scale=4
module racine(ParamRacine) : scale=4
module segment(seg) : scale=5
module tip(pte) : scale=5
module Site(primord) : scale=5
module IN
module FLW

TREE=[False,False,True,False,True]

### Creation du MTG ###
def my_axialtree2mtg(tree, scale, scene, parameters, TREE=[]):
  def scene_id(scene):
    d={}
    if scene:
      for sh in scene:
        d.setdefault(sh.id,[]).append(sh)
      return d
  
  def change_id(axial_id, mtg_id):
    if geoms:
      if geoms.has_key(axial_id):
        for shape in geoms[axial_id]:
          shape.id=mtg_id
          mtg.property('geometry')[mtg_id]=geoms[axial_id]
      else:
        pass
  
  nombre=0 
  nombre2=0
  symbols=['IN','FLW','[',']']
  
  geoms=scene_id(scene)
  mtg=MTG()
  if scene:
    mtg.add_property('geometry')
  
  if parameters is None:
    parameters={}
  for label in parameters:
    for p in parameters[label]:
      if p not in mtg.property_names():
        mtg.add_property(p)
  
  vid=mtg.root
  current_vertex=vid
  branching_stack=[vid]
  pending_edge='' # edge type for the next edge to be created
  
  indoor=0
  follow=0  
  
  for aid, modul in enumerate(tree):
    label=modul.name
    
    if (label not in scale)and(label not in symbols):
      continue
    elif label =='IN':
      indoor=1
    
    elif label=='FLW':
      follow=1
    
    elif label == '[':
      if indoor==0 and follow==0:        
        branching_stack.append(current_vertex)
        pending_edge='+'
      elif indoor==1:
        indoor=0
      else:
        follow==0
    
    elif label == ']':
      if indoor==0 and follow==0 and branching_stack!=[0]:
        current_vertex=branching_stack.pop()
        pending_edge=''
      elif indoor==1:
        indoor=0
      else:
        follow=0
    
    else:
      nombre=nombre+1
      _scale=scale[label]
      _params=parameters.get(label, [])
      
      params={}
      params['label']=label
      for p in _params:
        if modul.hasParameter(p):
          params[p]=modul.getParameter(p)      
      
      if _scale==mtg.scale(current_vertex)+1:
        current_vertex=mtg.add_component(current_vertex, **params)
        if _scale==5:
          indoor=0
          follow=0
        nombre2=nombre2+1
      elif mtg.scale(current_vertex) == _scale: # Add a vertex at the finer scale
        if pending_edge == '+':
          edge_type='+'
        else:
          edge_type='<'
        params['edge_type']=edge_type
        current_vertex=mtg.add_child(current_vertex, **params)
        pending_edge=''
        nombre2=nombre2+1
      elif mtg.scale(current_vertex) > _scale:
        if TREE[_scale-1]==False:
          params['edge_type']=''
        else:
          if pending_edge=='+':
            edge_type='+'
          else:
            edge_type='<'
          params['edge_type']=edge_type
          
        while mtg.scale(current_vertex) > _scale:
          current_vertex=mtg.complex(current_vertex)
        
        current_vertex=mtg.add_child(current_vertex, **params)
        vid=current_vertex
        pending_edge=''
        nombre2=nombre2+1
      
      if label=='Feuille' or _scale==len(TREE)-1:
        change_id(aid,current_vertex)
  
  mtg=fat_mtg(mtg)
  return mtg

def LongueurFeuilleCoupee(segments_feuille,ID): #Renvoie idLong si hauteur>HCOUP, renvoie -1 si hauteur<HCOUP
  for x in segments_feuille:
    if x[0].hauteur > ParamP[ID]['HCOUP']:
      return x[0].idLong  # Retourne l'id du 1er segment coup�
  return -1 

########   Fonction racinaires   ########
def Gravitropisme(ID,vertex,segment,profondeur,elong,init):#age,ordre,Turtle):
  global mtg
  Tortue=mtg.property('pte').get(vertex).Tortue
  if (Order(vertex)==0 and segment==0 and init==1):# idem a (age==0 and ordre==0) signifie 1ere croissance de la racine
    alpha=pi
    while alpha> (pi/2):
      alpha=random.normalvariate(ParamP[ID]['P_angInitMoyVertPrim'],ParamP[ID]['P_angInitETVertPrim'])
    beta=random.random()*2*pi 
  
  elif (segment==0 and init==1):# idem a age=0 signifie 1ere croissance d'une laterale
    alpha=ParamP[ID]['P_angLat']
    beta=random.random()*2*pi
  
  else:
    tortue=np.array([Tortue[:,0]])/np.linalg.norm(Tortue[:,0]) # vect direction pointe
    G=np.array([0,0,-ParamP[ID]['P_intensiteTropisme']*elong*mtg.property('pte').get(vertex).diametre]) # vect gravitropisme
    
    ### vect meca ###
    cont=float(Sol[Couche(ID,profondeur)][2])
    #Dx=random.random()*2-1
    #sign=(floor(random.random()*2))*2-1
    #Dy=sign*sin(acos(Dx))
    #Meca=0.5*(Dx*np.array([Tortue[:,1]]/np.linalg.norm(Tortue[:,1]))+Dy*np.array([Tortue[:,2]]/np.linalg.norm(Tortue[:,2])))
    
    if Sol[Couche(ID,profondeur)][3]==1:#(oCMecaSol(sol,profondeur)==1)  # Contrainte anisotrope verticale
      # On est dans le cas ou le sol est compose de nombreux tunnel verticaux de vers de terre qui entraine une orientation assez verticale des racines
      teta=15*pi/180
      ang_insertion=random.random()*2*teta-teta
      ang_radial=random.random()*2*pi
      RotLeft=np.array([[1,0,0],[0,cos(ang_radial),-sin(ang_radial)],[0,sin(ang_radial),cos(ang_radial)]])
      RotUp=np.array([[cos(ang_insertion),sin(ang_insertion),0],[-sin(ang_insertion),cos(ang_insertion),0],[0,0,1]])  
      Rot=np.dot(Tortue,RotLeft)
      Meca=np.dot(Rot,RotUp)/np.linalg.norm(Meca[:,0])*elong *cont
    
    else:
      ang_insertion=random.random()*pi-pi/2
      ang_radial=random.random()*2*pi
      RotLeft=np.array([[1,0,0],[0,cos(ang_radial),-sin(ang_radial)],[0,sin(ang_radial),cos(ang_radial)]])
      RotUp=np.array([[cos(ang_insertion),sin(ang_insertion),0],[-sin(ang_insertion),cos(ang_insertion),0],[0,0,1]])
      Rot=np.dot(Tortue,RotLeft)
      Meca=np.dot(Rot,RotUp)
      Meca=Meca[:,0]/np.linalg.norm(Meca[:,0])
      Meca=Meca*elong*cont
    
    ### vect final ###
    newtortue=tortue+G+Meca
    newtortue=newtortue/np.linalg.norm(newtortue)
    A=np.array([0.,0.,0.])
    for i in range(3):
      a=np.array([Tortue[0,:],Tortue[1,:],Tortue[2,:]])
      a[:,i]=newtortue
      A[i]=np.linalg.det(a)/float(np.linalg.det(Tortue))
    
    A=A/np.linalg.norm(A)
    alpha=acos(A[0])
    beta=acos(-A[1]/sin(alpha))
    
    if ((A[2] <0 and -sin(alpha)*sin(beta)>0) or (A[2] >0 and -sin(alpha)*sin(beta)<0)) :
      beta=-beta    
  
  RotLeft=np.array([[1,0,0],[0,cos(beta),-sin(beta)],[0,sin(beta),cos(beta)]])
  RotUp=np.array([[cos(alpha),sin(alpha),0],[-sin(alpha),cos(alpha),0],[0,0,1]])
  Rot=np.dot(Tortue,RotLeft)
  newTurtle=np.dot(Rot,RotUp)
  #newTurtle[:,0]=newTurtle[:,0]/np.linalg.norm(newTurtle[:,0])
  
  pos=mtg.property('pte').get(vertex).posO
  newpos=pos+newTurtle[:,0]*elong
  return (newTurtle,newpos)

#def CroissanceRacine(X,profondeur):
#  ID=X.id_plante
#  return (X.diametre - ParamP[ID]['P_diamMin'])* dt * ParamP[ID]['P_penteVitDiam'] * float(Sol[Couche(ID,profondeur)][0])
#  #return ParamP[ID]['P_elongMax']*(1+(max(0,(ParamP[ID]['P_diamMax']-X.diametre))/(ParamP[ID]['P_diamMax']-ParamP[ID]['P_diamVM'])))*pow((min(1,(X.diametre-ParamP[ID]['P_diamMin'])/(ParamP[ID]['P_diamMax']-ParamP[ID]['P_diamMin']))),((ParamP[ID]['P_diamMax']-ParamP[ID]['P_diamMin'])/(ParamP[ID]['P_diamMax']-ParamP[ID]['P_diamVM'])))

def CroissanceRacine2(X,profondeur):
  ID=X.id_plante
  if X.diametre>ParamP[ID]['P_diamMax']:
    return ParamP[ID]['P_elongMax']
  else:
    return ParamP[ID]['P_elongMax']*(1+(max(0,(ParamP[ID]['P_diamMax']-X.diametre))/(ParamP[ID]['P_diamMax']-ParamP[ID]['P_diamVM'])))*pow((min(1,(X.diametre-ParamP[ID]['P_diamMin'])/(ParamP[ID]['P_diamMax']-ParamP[ID]['P_diamMin']))),((ParamP[ID]['P_diamMax']-ParamP[ID]['P_diamMin'])/(ParamP[ID]['P_diamMax']-ParamP[ID]['P_diamVM'])))

def tireDiamPointeFille(ID,diametre_pere): # Tire le diametre d'un meristeme de ramification suivant celui du pere pour la ramification sequentielle
  moy=diametre_pere*ParamP[ID]['P_propDiamRamif'] #+ (ParamP[ID]['P_diamMin']*(1.0-ParamP[ID]['P_propDiamRamif']))
  et=moy*ParamP[ID]['P_coeffVarDiamRamif']
  diamPFille=10.0 # Initialisation a une forte valeur
  while (diamPFille>(1.1*diametre_pere)):
     diamPFille=random.normalvariate(moy,et)
  return diamPFille

#def Distance(v1,v2):  
#  dist=0
#  chemin=Path(v1,v2)
#  chemin.append(v1)
#  for x in chemin:
#    if Class(x)=='s':
#      geo=g.property('geometry').get(x)[0]
#      points=geo.geometry.axis.pointList
#      long=sqrt((points[0][0]-points[1][0])**2+(points[0][1]-points[1][1])**2+(points[0][2]-points[1][2])**2)
#      dist=dist+long
#  return dist

def Couche(ID,profondeur):
  hor=-floor(profondeur/ParamP[ID]['epaisseurHorizon'])
  if hor>=ParamP[ID]['NBHORIZONMAX']:
    hor=ParamP[ID]['NBHORIZONMAX']-1
  if hor<0:
    hor=0  
  return int(hor)

def DetermineAccroiss(Pourcentage,X,AccroissDemande):
  newbiomass=X.biomass+X.Besoinencroiss*Pourcentage
  if newbiomass>X.biomass:
    newtaille=X.Taillefeuille
    while BiomassFeuille(newtaille,X.coupe,X.id_geno)<newbiomass and newtaille<(X.Taillefeuille+AccroissDemande):
      newtaille+=0.1
    newtaille=newtaille-0.1
    while BiomassFeuille(newtaille,X.coupe,X.id_geno)<newbiomass and newtaille<(X.Taillefeuille+AccroissDemande):
      newtaille+=0.01
    return newtaille-0.005-X.Taillefeuille
  else:
    return 0

def BiomassFeuille(long,coupe,geno):
  coupe=0
  if geno<2:  # Thibault (20/04/2020) : cette condition n'est plus valable, il faut remplacer id_geno par l'identifiant de la ligne sur laquelle se trouve la plante
    if long==0:
      MS=0
    else:
      MS=paramManagement['FacBiom1']*(paramManagement['b0']*exp(paramManagement['b1']*(long+coupe)**2+paramManagement['b2']*(long+coupe))-paramManagement['b0'])*(long/(long+coupe))
  else:
    if long==0:
      MS=0
    else:
      MS=paramManagement['FacBiom2']*(paramManagement['b0']*exp(paramManagement['b1']*(long+coupe)**2+paramManagement['b2']*(long+coupe))-paramManagement['b0'])*(long/(long+coupe))
  return MS

# --------------------------------------------
#  ---------- LAI proximite ------------------
# --------------------------------------------
def LAI_proximite(id_plante):
  """
  calcul du LAI proximite a partir surface plante cible (auto-ombrage) + surface des 8 plantes adjacentes
  """
  
  def posTOnum(pos): #Determination de l'id de la plante a partir de la position
    id_plante = -1
    for i in range((NBlignes)*(NBcolonnes)):
      if (posPlante[i] == pos):
        id_plante = i
    return id_plante
  
  def numTOpos(id_plante): #Determination de la position de la plante a partir de l'id
    return posPlante[id_plante]
  
  def deplacPos(pos, depl): #Selectionne la plante adjacente donnee
    ret=list(pos)  #Cree une copie de pos
    if ((depl[0]==-1 or depl[0]==0 or depl[0]==1) and (depl[1]==-1 or depl[1]==0 or depl[1]==1)): #Valeurs entre -1 et 1 : plantes adjacentes et non a 2 espacements
      ret[0]=pos[0] + depl[0]
      ret[1]=pos[1] + depl[1]
      #Simulation d'un couvert de taille infini:
      if (ret[0] == -1): ret[0] = NBlignes-1
      if (ret[0] == NBlignes): ret[0] = 0
      if (ret[1] == -1): ret[1] = NBcolonnes-1
      if (ret[1] == NBcolonnes): ret[1] = 0
    return ret
  
  def adj9Plantes(pos): #Fait la liste des plantes adjacentes + plante cible
    position_plantes_adjacentes = []
    for p in itertools.product([-1,0,1], [-1,0,1]):
      position_plantes_adjacentes.append(deplacPos(pos, p))
    return position_plantes_adjacentes
  
  def surfol9Plantes(id_plante): #Calcule la surface foliaires des 9 plantes adjacentes
    position_plantes_adjacentes = adj9Plantes(numTOpos(id_plante)) # liste des positions des plantes adjacentes
    surface_9_plantes = 0
    for p in position_plantes_adjacentes:
      if posTOnum(p)>-1:
        surface_9_plantes += surface_foliaire_emergee[posTOnum(p)]
    return surface_9_plantes
  
  nb_plantes = 9
  LAI_proximite = surfol9Plantes(id_plante) / (Espacement**2 * nb_plantes)
  return LAI_proximite

# --------------------------------------------

def Start():
  global timing,growth_realized,dt,TPS,TPS_expe #Parametres de temps
  global df_induction, df_organ_lengths
  global surface_biomass,chemin_fichier1,chemin_fichier2,chemin_fichier3,long_root,simul_expe,taille_finale_feuille, outvarfile #Fichiers de sortie
  global Biomasse_aerienne,Biomasse_racinaire,BiomProd,PourcentageRootGrowthRealized,PourcentageRootGrowthRealized,Reserve,Demande_feuille,PourcentageFeuilGrowthRealized,les_diametres,Seuil,Taille_finale_gaine,nb_talle #Parametres vides
  global NBlignes,NBcolonnes,posPlante,Espacement #Parametres scene
  global surface_foliaire_emergee,Surfoliaireencours,Premiecroiss #Definition des groupes de production
  global Alpha,Beta,t1,t2,t3 #Relation allometrique
  global current_day, meteo, tiller_appearance, tiller_to_remove
  #Ajout variables globales pour sauvegarde de lstring 03/06/2020
  global les_feuilles
  
  # Camera setting
  #Viewer.camera.lookAt((250,250,50),(-100,-100,50))#((Position),(direction))
  
  
  ##### Parametres de temps #####
  timing=t.time()
  growth_realized=1
  dt=1
  TPS=0.
  TPS_expe=range(1000)
  
  
  
  
  
  # ------------------------------------------------------------------------------------------------
  # -------------------------------- Thermal time calculation --------------------------------------
  # ------------------------------------------------------------------------------------------------
  meteo = meteo_ephem.import_meteo_data(meteo_path, sowing_date, site)
  current_day = meteo.experimental_day.tolist()[0]
  
  # Ajout Thibault 03/06/2020
  # Recuperation des variables issues de la simulation sauvegardee
  if OptionAxiom: 
    from lgrass import gen_lstring
    Biomasse_aerienne, Biomasse_racinaire, PourcentageRootGrowthRealized, Reserve, Demande_feuille, PourcentageFeuilGrowthRealized, les_diametres, Seuil, Taille_finale_gaine, nb_talle, surface_foliaire_emergee, Surfoliaireencours, les_feuilles = gen_lstring.load_variables()
    
  else:
    ##### Creation de parametres vides #####
    Biomasse_aerienne=[0.]*(nb_plantes) # Biomasse foliaire totale
    Biomasse_racinaire=[0.]*(nb_plantes) # Biomasse racinaire
    PourcentageRootGrowthRealized=[0]*(nb_plantes)
    Reserve=[0]*(nb_plantes) # Reserve de "biomass"
    Demande_feuille=[0]*(nb_plantes)
    #Next_biom_feuil=[0]*(nb_plantes)
    PourcentageFeuilGrowthRealized=[1]*(nb_plantes)
    les_diametres=[]
    Seuil=[] # Taille a partir de laquelle la plante est consideree comme hors de la gaine
    Taille_finale_gaine=[]
    nb_talle=[]  # nombre_de_talle-1 pour chaque plante afin d'identifier les talles
    ligule_height_dict = {}
    
    ##### Definition des groupes de production #####
    surface_foliaire_emergee =[0.]*(nb_plantes) # Surface foliaire �merg�e totale obtenue a la fin d'un pas
    Surfoliaireencours=[0.]*(nb_plantes) # variable de calcul de la surface foliaire totale
  
  Premiecroiss=[ParamP[i]['Premiecroiss'] for i in range(nb_plantes)]
  
  ##### Relation allometrique #####
  Alpha=[ParamP[i]['Alpha'] for i in range(nb_plantes)]
  Beta=[ParamP[i]['Beta'] for i in range(nb_plantes)]
  t1=[ParamP[i]['t1'] for i in range(nb_plantes)]
  t2=[ParamP[i]['t2'] for i in range(nb_plantes)]
  #t3=[ParamP[i]['t3'] for i in range(nb_plantes)]
  
  df_induction = pd.DataFrame(columns = ['GDD', 'Date', 'Site', 'Day', 'Daily_mean_temperature', 'Daily_daylength', 'Id_plante', 'Id_talle', 'topology', 'Leaf_produced', 'Primordia_on_apex', 'Spikelet_number', 'Vernalisation_rate', 'Secondary_induction_rate', 'Heading_date'])
  
  df_organ_lengths = pd.DataFrame(columns = ['GDD', 'Date', 'Site', 'Day', 'Id_plante', 'Id_talle', 'Id_rang', 'Organ', 'Length'])
  
  tiller_appearance = pd.DataFrame()
  
  tiller_to_remove = pd.DataFrame()
  
#  ##### Ecriture des fichiers de sortie #####
  outvarfile='%s_surface_biomass.csv'%(name_sim)
  outvarfile2='%s_feuilles_finales.csv'%(name_sim)
##output_apex = 'output_apex_%s_%s_%s.csv'%(int(Espacement),DureeExp,ParamP[0]['HCOUP'])                  # Ajout SIMON
#output_organ_characteristics = 'output_organ_characteristics%s_%s_%s.csv'%(int(Espacement),DureeExp,ParamP[0]['HCOUP'])    
#outimage='Scene\scene_'+str(int(Espacement))+'_'+t.strftime('%d-%m-%y_%Hh%M',t.localtime())+'.bmp'
  chemin_fichier1=open(os.path.join(OUTPUTS_DIRPATH,outvarfile),"w")
  surface_biomass=csv.writer(chemin_fichier1)
  surface_biomass.writerow(["TPS","Espacement","Densite","id plante","id talle","topology","nb_feuille_emergees","Biomasse_feuilles_emergees","Surface_feuilles_emergees"])
  
  chemin_fichier2=open(os.path.join(OUTPUTS_DIRPATH,outvarfile2),"w")
  taille_finale_feuille=csv.writer(chemin_fichier2)
  taille_finale_feuille.writerow(["TPS","Espacement","Densite","id plante","talle","rang","Phase","taille feuille","taille gaine","taille limbe"])


def StartEach(lstring):
  global RootPotentialNewBiomass,longueur_totale_feuille,Rootbiom,groupe,dt,reprise_coupe,CoupeTaille
  global df_induction, df_organ_lengths
  global current_day, meteo, tiller_appearance, tiller_to_remove, mortality_zone, changing_day_cutting
#  global apex_characteristics, internode_characteristics
  
  
  
  
  
  RootPotentialNewBiomass=[0]*(nb_plantes)
  longueur_totale_feuille=0
  Rootbiom=0
  
  for ID in range(nb_plantes):
    # AJOUT SIMON 24-12-2019
    
    if current_day in cutting_dates and changing_day_cutting == True:
      ParamP[ID]['DCOUP'] = TPS
      changing_day_cutting = False
    if current_day not in cutting_dates:
      changing_day_cutting = True
    
    ### Declenchement de la coupe selon la date ###
    if TPS==ParamP[ID]['DCOUP']:
      if groupe=='croissance':
        groupe='defoliation'
        dt=0.25
        print('coupe')
    
    if (TPS==ParamP[ID]['DCOUP']+1.):
      if groupe=='defoliation':
        if cutting_dates is None:  #Ajout Thibault (17/04/2020) pour eviter de confondre les 2 methodes de gestion des coupes
          if ParamP[ID]['DCOUP']+ParamP[ID]['FREQUCOUPE'] < ParamP[ID]['PREMIERCOUPE']+ParamP[ID]['DUREECOUPE']:
            ParamP[ID]['DCOUP']=ParamP[ID]['DCOUP']+ParamP[ID]['FREQUCOUPE']
            print('prochaine_coupe',ParamP[ID]['DCOUP'])
        reprise_coupe=True
        groupe='croissance'
        dt=1
        
    if TPS==ParamP[ID]['DCOUP']+0.75:
      for i in range(len(Seuil)):
        for j in range(len(Seuil[i])):
          Seuil[i][j]=5.5
          
  
  
  #### R�gression des talles : D�termination des zones o� appliquer le Cut
  if option_tiller_regression == True and current_day > 1:
    mortality_zone = pd.DataFrame()
    for i in [i for i in range(len(lstring))]:
     if lstring[i] == '[' and lstring[i+1] == 'phytomere':
       mortality_zone = mortality_zone.append(pd.DataFrame({'id_plante': [lstring[i+1][0].id_plante], 'id_talle': [lstring[i+1][0].id_talle], 'id_rang': [lstring[i+1][0].id_rang]}))
    
    
    
    
    
    ### Declenchement de la coupe selon la taille de la plante ###
    #if TPS>1 and groupe=='croissance':
    #  for x in les_feuilles:
    #    if mtg.property('ParamFeuille').get(x).Taillefeuille>(1.5*ParamP[ID]['HCOUP']):
    #      groupe='defoliation'
    #      dt=0.25
    #      CoupeTaille=TPS
    #      print CoupeTaille
    #
    #if (TPS==CoupeTaille+1) and groupe=='defoliation':
    #  reprise_coupe=True
    #  groupe='croissance'
    #  dt=1
    
    ### Declenchement de la coupe selon la lumiere transmise ###
    
    ### Declenchement de la coupe selon le LAI ###
    


def EndEach(lstring, lscene):
  global simul_expe,surface_biomass,taille_finale_feuille
  global TPS,dt,mtg,surface_foliaire_emergee,les_pointes,les_primordiums,RootPotentialNewBiomass,les_feuilles,les_feuilles_emergees, les_segments_feuilles, les_racines, Reserve,Biomasse_aerienne,Surfoliaireencours,Biomasse_racinaire,fichier_test,groupe,PourcentageRootGrowthRealized,PourcentageFeuilGrowthRealized,Demande_feuille,C,reprise_coupe,BiomProd, rapportS9_SSol_dict
  global current_day, meteo
  global df_induction, df_organ_lengths, tiller_appearance, tiller_to_remove
#  global apex_characteristics, internode_characteristics # AJOUT SIMON
  
  TPS=TPS+dt
  print('TPS :',TPS , 'Current day :', current_day) # AJOUT SIMON
  
  if reprise_coupe==True:
    reprise_coupe=False
  
  liste_organes = []
  for mod in lstring:
    if mod.name in ('Feuille', ):
      liste_organes.append({'Plante': mod[0].id_plante, 'id_talle': mod[0].id_talle, 'id_rang': mod[0].id_rang, 'Topology': mod[0].topology, 'Organe': mod.name, 'ObjetOrgane': mod[0], 'Phase': mod[0].Phase})
  df_organes = pd.DataFrame(liste_organes, columns=['Plante', 'id_talle', 'id_rang', 'Topology', 'Organe', 'ObjetOrgane', 'Phase'])
  
  les_feuilles = df_organes[(df_organes['Organe'] == 'Feuille')] # Toutes les feuilles de toutes les plantes
  
  rapportS9_SSol_dict = {}
  for id_plante in les_feuilles['Plante'].unique():
    les_feuilles_plante = les_feuilles[les_feuilles['Plante'] == id_plante]
    Biomasse_aerienne[id_plante] = 0
    surface_foliaire_emergee[id_plante] = 0
    Demande_feuille[id_plante] = 0
    for id_talle in les_feuilles_plante['id_talle'].unique():
      # Toutes les feuilles de la talle
      les_feuilles_talle = les_feuilles_plante[les_feuilles_plante['id_talle'] == id_talle]['ObjetOrgane'].tolist()
      
      # Demande croissance de toutes les feuilles de la talle
      Demande_feuille[id_plante] += sum([x.Besoinencroiss for x in les_feuilles_talle])
      
      # Biomasse et surface des feuilles emergees uniquement
      Biomasse_aerienne[id_plante] += sum([x.biomass for x in les_feuilles_talle])
      surface_foliaire_emergee[id_plante] += sum([x.surface_limbe for x in les_feuilles_talle])  #: N'ajoute que les surfaces de limbes emerges
      # ajoute les surfaces des gaines emergees � partir de Seuil
      seuil_talle = Seuil[id_plante][id_talle]
      diametre_seuil_talle = max((2 / pi) * (paramManagement['CoefDirLonLarAjust'] * log(max(seuil_talle * 5,1)) - paramManagement['OrdOriLonLarAjust']), 0.1)
      surface_gaine_emergee = (seuil_talle * pi * diametre_seuil_talle) / 2  # Surface projetee
      surface_foliaire_emergee[id_plante] += surface_gaine_emergee
      
      ##### Remplissage du fichier surface_biomass #####
      surface_biomass.writerow([TPS,Espacement,Densite,id_plante+1, id_talle+1, les_feuilles_talle[0].topology, len(les_feuilles_talle),sum(x.biomass for x in les_feuilles_talle),sum(x.surface_limbe for x in les_feuilles_talle) + surface_gaine_emergee])
    
    # Calcul LAI proximite
    rapportS9_SSol_dict[id_plante] = LAI_proximite(id_plante)    
    
    # Mise a jour biomasse et pourcentage echelle plante
    if Biomasse_aerienne[id_plante]>0 and t1[id_plante]*exp(TPS*t2[id_plante])-t1[id_plante]>0 and surface_foliaire_emergee[id_plante] > 0 and Demande_feuille[id_plante] != 0: #Verifie qu'il y a une partie aerienne et que TPS, t1 et t2 sont positifs          # surface_foliaire_emergee[ID] > 0 and Demande_feuille[ID] > 0 : ajout SIMON
      # Calcul biomasse creee
      if option_morphogenetic_regulation_by_carbone == True:
        # Approche RUE
        BiomassCree = BiomProd[id_plante]
      else:
        # Approche croissance biomasse exponentielle (cf th�se Vincent Migault)
        BiomassCree=t2[id_plante]*(Biomasse_aerienne[id_plante]+t1[id_plante])*(1+Beta[id_plante]*Alpha[id_plante]*(Biomasse_aerienne[id_plante])**(Alpha[id_plante]-1))

      # Allocation aerien/racinaire + ratio offre/demande
      if BiomassCree>0 and 0.99*BiomassCree > Demande_feuille[id_plante]:  # demande satisfaite
        RootBiomassCree = BiomassCree - Demande_feuille[id_plante]  # Allocation surplus non utilise par parties aeriennes aux racines
        Biomasse_racinaire[id_plante] += RootBiomassCree
        PourcentageFeuilGrowthRealized[id_plante] = 1  # Pas de limitation croissance foliaire pour prochain pas de temps
      else:  # Demande non satisafite
        RootBiomassCree = 0.01*BiomassCree  # Racines ne prennent qu'1% de l'offre
        Biomasse_racinaire[id_plante] += RootBiomassCree
        BiomassFeuilCree = 0.99*BiomassCree
        PourcentageFeuilGrowthRealized[id_plante] = max(0, BiomassFeuilCree / Demande_feuille[id_plante]) # Reduction croissance foliaire potentielle au prorata offre/demande pour prochain pas de temps
    else:
      RootBiomassCree=0
      BiomassCree=0
    
    if RootPotentialNewBiomass[id_plante]==0:
      PourcentageRootGrowthRealized[id_plante]=0
      #Reserve[ID]=Reserve[ID]+RootBiomassCree
    else:
      PourcentageRootGrowthRealized[id_plante]=RootBiomassCree/RootPotentialNewBiomass[id_plante]
      if PourcentageRootGrowthRealized[id_plante]>1:
        PourcentageRootGrowthRealized[id_plante]=1
        #Reserve[ID]=Reserve[ID]+(RootBiomassCree-RootPotentialNewBiomass[ID])
      else:
        if RootPotentialNewBiomass[id_plante]-RootBiomassCree < Reserve[id_plante]:
          PourcentageRootGrowthRealized[id_plante]=1
          #Reserve[ID]=Reserve[ID]-(RootPotentialNewBiomass[ID]-RootBiomassCree)
        else:
          PourcentageRootGrowthRealized[id_plante]=(RootBiomassCree+Reserve[id_plante])/RootPotentialNewBiomass[id_plante]
          #Reserve[ID]=0
    
  if groupe == 'defoliation':
    les_segments_feuilles = [x for x in lstring if x.name=='SegFeuille']
  
  if OptionRacine!='SansRacines':
    mtg=my_axialtree2mtg(lstring, scales,None, parameters,TREE)
    Activate(mtg)
    les_racines=[x for x in VtxList(4) if Class(x)=='r']
    les_pointes=[[mtg.property('pte').get(x).id_pointe,x] for x in VtxList(5) if Class(x)=='t']
    les_pointes2=[x for x in VtxList(5) if Class(x)=='t']
  
  # ------------------------------------------------------------------------------------------------
  # -------------------------------- Date change management ----------------------------------------
  # ------------------------------------------------------------------------------------------------
  # Date change occurs when the global time flow in growing degree day (GDD) reachs the GDD cumul of
  # the current day (from the start of the meteorological data)
  # ------------------------------------------------------------------------------------------------
  if TPS >= meteo[meteo.experimental_day == current_day].thermal_time_cumul.iloc[0]:
    current_day += 1
    

def End(lstring,lscene): #Ecriture et fermeture des fichiers de sortie
  global taille_finale_feuille,surface_biomass,simul_expe, outvarfile, Espacement
  global TPS,timing,chemin_fichier1,chemin_fichier2,chemin_fichier3,mtg,long_root, les_racines, apex_characteristics, internode_characteristics
  global df_induction, df_organ_lengths
  
  
  ### Remplissage du fichier taille_finale_feuille ###
  for ID in range(nb_plantes):
    les_feuilles_emergees = les_feuilles[(les_feuilles['Plante'] == ID) & (les_feuilles['Phase'] == 'mature')]['ObjetOrgane'].tolist()
    for x in les_feuilles_emergees:
      taille_finale_feuille.writerow([TPS, Espacement, Densite,ID+1, x.id_talle+1, x.id_rang+1, x.Phase, x.Taillefeuille, x.Taillegaine, x.Taillelimbe])
  
  nb_racines=[0]*nb_plantes
  nb_racines_visible=[0]*nb_plantes
  longroottotal=[0]*nb_plantes
  longueurtotale=[0]*nb_plantes
  profond=[0]*nb_plantes

  if OptionRacine!='SansRacines':
    for x in les_racines:
      long=0
      ensemble_de_racine=Components(x)
      ID=mtg.property('ParamRacine').get(x).id_plante
      
      for y in ensemble_de_racine:
        if Class(y)=='s':
          longueurtotale[ID]+=mtg.property('seg').get(y).longueur
        elif Class(y)=='t':
          longueurtotale[ID]+=mtg.property('pte').get(y).longueur
      axe=Path(ensemble_de_racine[0],ensemble_de_racine[len(ensemble_de_racine)-1])
      axe.append(ensemble_de_racine[0])
      
      for y in axe:
        if Class(y)=='s':
          long=long+mtg.property('seg').get(y).longueur
        elif Class(y)=='t':
          long=long+mtg.property('pte').get(y).longueur
      longroottotal[mtg.property('ParamRacine').get(x).id_plante]+=long
      nb_racines[mtg.property('ParamRacine').get(x).id_plante]+=1
      if long>5:
        nb_racines_visible[mtg.property('ParamRacine').get(x).id_plante]+=1
      pointe=axe[len(axe)-2]
      profond[mtg.property('ParamRacine').get(x).id_plante]=max(profond[mtg.property('ParamRacine').get(x).id_plante],mtg.property('pte').get(pointe).profondeur)
  
  ### Fermeture des fichiers ###
  chemin_fichier1.close()
  chemin_fichier2.close()
  
#  ### Sauvegarde d'une image de la scene
#  outimagepath = os.path.join(OUTPUTS_DIRPATH, outimage)
#  frameDisplay(True)
#  Viewer.display(lscene)
#  Viewer.camera.lookAt((800,400,100),(0,0,0)) #Pas la meme capture si pris avec lpy ou avec batch
#  Viewer.frameGL.setSize(1200,800) #Taille de la fenetre
#  Viewer.frameGL.saveImage(outimagepath)
#  Viewer.stop()
  
  #print(lstring)

  df_induction.to_csv(os.path.join(OUTPUTS_DIRPATH, output_induction_file_name + '.csv'), index = False)
  df_organ_lengths.to_csv(os.path.join(OUTPUTS_DIRPATH, output_organ_lengths_file_name + '.csv'), index = False)

  if option_graphic_outputs == True:
    from lgrass import Lgrass_plot_functions
    graphic = Lgrass_plot_functions.GraphicOutputs(GRAPHS_DIRPATH)
    graphic.graph_induction(os.path.join(OUTPUTS_DIRPATH, output_induction_file_name))
    graphic.graph_length(os.path.join(OUTPUTS_DIRPATH, output_organ_lengths_file_name))
    graphic.graph_tiller_number(os.path.join(OUTPUTS_DIRPATH, outvarfile))
    graphic.graph_LAI(os.path.join(OUTPUTS_DIRPATH, outvarfile), Espacement)
    graphic.graph_leaf_number(os.path.join(OUTPUTS_DIRPATH, outvarfile))
    


  print('Execution time :',t.time()-timing)




def FoncCroiss(t, Ymax, tend, tmax): # fonction de croissance de feuille
  if (t>tend):
    y=Ymax
  else:
    y=Ymax*(1+((tend-t)/(tend-tmax)))*(pow((t/tend),(tend/(tend-tmax))))
  return y

#def TpourY(Y, Ym, Te, Tm):  # retrouver le temps T auquel la taille de la feuille valait Y
#  L=0
#  i=0
#  if Y>Ym:
#    return Te
#  else:
#    while L<Y:
#      L=FoncCroiss(i, Ym, Te, Tm)
#      i=i+1
#    j=max(i-1,0)
#    L=FoncCroiss(j, Ym, Te, Tm)
#    
#    while L<=Y:
#      L=FoncCroiss(j, Ym, Te, Tm)
#      j=j+0.1
#    k=max(j-1,0)
#    L=FoncCroiss(k, Ym, Te, Tm)
#    
#    while L<=Y:
#      L=FoncCroiss(k, Ym, Te, Tm)
#      k=k+0.01
#    l=max(k-1,0)
#    L=FoncCroiss(l, Ym, Te, Tm)
#    
#    while L<=Y:
#      L=FoncCroiss(l, Ym, Te, Tm)
#      l=l+0.001
#    return max(l-0.001,0)

def TpourY2(Y, Ym, Te, Tm):  # retrouver le temps T auquel la taille de la feuille valait Y
  curs1=0
  curs2=Te
  newt=Te/2
  while curs2-curs1>0.001:
    newt=curs1+(curs2-curs1)/2
    L=FoncCroiss(newt, Ym, Te, Tm)
    if L==Y:
      return newt
    elif L<Y:
      curs1=newt
    else:
      curs2=newt
  return curs1+(curs2-curs1)/2


  
def gener_lstring():  #Ajout Thibault 02/06/2020 Initialiser l'axiom avec une chaine existante ou non
  if OptionAxiom:
    from lgrass import gen_lstring
    modulenamelist, moduleparam = gen_lstring.load_lstring()
    for n,p in zip(modulenamelist, moduleparam):
      if p == None:
        nproduce new(n)
      elif len(p) == 1:
        nproduce new(n,p[0])
      elif len(p) == 2:
        nproduce new(n,p[0],p[1])
      elif len(p) == 3:
        nproduce new(n,p[0],p[1],p[2])
      elif len(p) == 4:
        nproduce new(n,p[0],p[1],p[2],p[3])
  else:
    produce CouvertVegetal(0)



Axiom: 
  #CouvertVegetal(0)
  gener_lstring()

derivation length: DureeExp


production:

GetPos(a,b,c)<SegFeuille(X):
  X.hauteur=c
  produce SegFeuille(X)


GetPos(a,b,c)<tip(X):
  X.profondeur=-c
  produce tip(X)


CouvertVegetal(X):
  global groupe,NBlignes,NBcolonnes,genotype
  if groupe=='croissance':
    if X==1:
      nproduce CouvertVegetal(2)
      for i in range(NBlignes):
        for j in range(NBcolonnes):
          #id_plante=i*NBcolonnes+j
          #id_geno=i
          id_plante = Plantes[i][j]
          id_geno = Genotypes[i][j]
          genotype.append(id_geno)
          param=ParamPlante(id_plante,id_geno)
          nb_talle.append(0)
          Seuil.append([5.5])
          Taille_finale_gaine.append([[5.5,5.5]])
          nproduce IN SB() RollR(45) MoveTo(j*Espacement,Espacement*i,0) Plante(param) IN EB()
    else:
      produce CouvertVegetal(X+1)
  if groupe=='defoliation':
    produce CouvertVegetal(X)


Plante(X):
  global TPS,groupe, current_day
  if groupe=='croissance':
    if TPS ==2:
      Y1=ParamPhytomere(id_plante = X.id_plante, id_talle = 0, id_rang=1)
      YF=ParamFeuille(age=0, Agecroiss=0, Taillefeuille=0, id_plante=X.id_plante ,id_rang=1, Ymax=Premiecroiss[X.id_plante], Taillefinalelimbe=0.8*Premiecroiss[X.id_plante], Taillefinalegaine=0.2*Premiecroiss[X.id_plante],id_geno=X.id_geno)
      Yb=ParambourgeonRoot(X.id_plante,id_talle=0,id_rang=1,id_geno=X.id_geno)
      YAT=ParamApexTal(X.id_plante,id_talle=0,id_rang=1,id_geno=X.id_geno)
      YA=ParamApex(X.id_plante, id_talle=0 ,id_rang=1, id_geno=X.id_geno, total_created_leaves=1)
      YINT=ParamEntrenoeud(X.id_plante,id_talle=0,id_rang=1)      # AJOUT SIMON
      
      # Remplissage des hauteurs d organes
      YA.organ_lengths_dict = {Y1.id_rang: {'limb': YF.Taillelimbe, 'sheath': YF.Taillegaine, 'internode': YINT.length}}
      
      produce Plante(X) phytomere(Y1, YA) RollR(95) bourgeonRoot(Yb, YINT) ApexTal(YAT) Entrenoeud(YINT, YA, YF, Y1) FLW SB Feuille(YF, YA, Y1) FLW EB apex(YA)
      
  if groupe=='defoliation':
    produce Plante(X)


phytomere(X, X_AP):
  global groupe, tiller_to_remove, mortality_zone
  if option_tiller_regression == True:
    if len(tiller_to_remove) > 0:
      if len(tiller_to_remove[(tiller_to_remove.id_plante == X.id_plante) & (tiller_to_remove.id_talle == X.id_talle)]) > 0 and len(mortality_zone[(mortality_zone.id_plante == X.id_plante) & (mortality_zone.id_talle == X.id_talle) & (mortality_zone.id_rang == X.id_rang)]) > 0:
        print('Tiller ', X.id_talle, ' of plant ', X.id_plante, ' is dead')
        produce Cut()
  else:
    if groupe == 'croissance':
      X.age=X.age+1
      if (X.id_talle!=0 and X.id_rang==1):
        if (X.age>=120 and X.angletal<=ParamP[X.id_plante]['divergetalle']):
          X.angletal=X.angletal+(1./3.)
    if groupe=='defoliation':
      produce phytomere(X, X_AP)


Feuille(X, X_apex, X_phytomere):
  global NewShootBiomass,longueur_totale_feuille,les_feuilles, les_segments_feuilles, Surfoliaireencours,groupe
  
  X.surface_limbe = 0
  
  if groupe=='croissance':
    X.age+=dt
    
    if(X.angleinsert<=ParamP[X.id_plante]['INSERTIONLIMBE'] and X.Taillegaine>Taille_finale_gaine[X.id_plante][X.id_talle][X.id_rang-1] +1):
      X.angleinsert=X.angleinsert+1    
    
    Seuil[X.id_plante][X.id_talle]=max(Seuil[X.id_plante][X.id_talle],X.Taillegaine)
    Taille_finale_gaine[X.id_plante][X.id_talle][X.id_rang]=max(Taille_finale_gaine[X.id_plante][X.id_talle][X.id_rang],X.Taillegaine)
    
    if X.Phase!='mature':
      ##### Modif potentiel apres coupe ######
      if reprise_coupe==True and X.Phase=='visible':
        LEDGAINE=((0.2*110*5)*2)-110
        TrueAge=TpourY2(Seuil[X.id_plante][X.id_talle],paramManagement['Yfinit'], paramManagement['Jled']*LEDGAINE,paramManagement['Kled']*paramManagement['Jled']*LEDGAINE) #Jled*LEDGAINE correspond a te, Kled*Jled*LEDGAINE correspond a tm (These Alban Verdenal)
        NewYmax=ParamP[X.id_plante]['C']*((pow(paramManagement['T01'],(TrueAge+paramManagement['tb1'])*paramManagement['k1'])-paramManagement['Lpot'])-(pow(paramManagement['T02'],(TrueAge+paramManagement['tb2'])*paramManagement['k2']))) # Fonction potentiel de croissance
        if NewYmax>X.Ymax:
          NewYmax=X.Ymax
        elif NewYmax<X.Taillefeuille+X.coupe:
          X.Phase='mature'
        else:
          #LED1=((X.Taillefinalegaine*5)*2)-X.Ymax
          NewTaillefinaleg=X.rapportK * NewYmax
          LED2=((NewTaillefinaleg*5)*2)-NewYmax
          X.Difftps=TpourY2(X.Taillefeuille+X.coupe,NewYmax,paramManagement['Jled']*LED2,paramManagement['Kled']*paramManagement['Jled']*LED2)-X.age
          #TpourY2(Seuil[X.id_plante][X.id_talle], X.Ymax,paramManagement['Jled']*LED,paramManagement['Kled']*paramManagement['Jled']*LED)-X.age#TpourY2(X.Taillefeuille+X.coupe,paramManagement['Yfinit'], paramManagement['Jled']*LEDGAINE,paramManagement['Kled']*paramManagement['Jled']*LEDGAINE)
          X.Agecroiss=X.Difftps+X.age
          X.Ymax=NewYmax
        
        X.Taillefinalelimbe=(1-X.rapportK)*X.Ymax
        X.Taillefinalegaine=X.rapportK*X.Ymax
      
      ###### Gestion passage phase cachee a phase visible ######
      if X.Phase=='cachee':
        if X.Taillefeuille > Seuil[X.id_plante][X.id_talle]:
          X.Phase='visible'
          X_apex.total_emerged_leaves += 1                                                      # Ajoute une feuille visible a l apex
          Seuil[X.id_plante][X.id_talle] *= 1.
          LEDGAINE=((0.2*Premiecroiss[X.id_plante]*5)*2)-Premiecroiss[X.id_plante]
          X.TailleEmergence=Seuil[X.id_plante][X.id_talle]
          TrueAge=X.age-dt #On pourrait affiner la determination de TrueAge qui en realite a eu lieu entre age-dt et age-2dt (soit on prend la moyenne soit au prorata des longueurs)

          genotype=X.id_geno

          if TrueAge < 118:
            X.Ymax = ParamP[X.id_plante]['C']*((pow(paramManagement['T01'],(TrueAge+paramManagement['tb1'])*paramManagement['k1'])-paramManagement['Lpot'])-(pow(paramManagement['T02'],(TrueAge+paramManagement['tb2'])*paramManagement['k2']))) #Alban
          else:
            X.Ymax = ParamP[X.id_plante]['C']*338.5554
          #X.Ymax=ParamP[genotype]['C']*(1*exp(0.032*(TrueAge+paramManagement['tb1']))-1*exp(0.047*(TrueAge+paramManagement['tb2']))-paramManagement['Lpot'])  #TF
          
          #else:
          #  X.Ymax=0.7*(1*exp(0.0110422966*(TrueAge+772.67636741))-1*exp(0.0113550477*(TrueAge+743.16065674))-602.78369237) #C=0.7
          #  #X.Ymax=(1*exp(0.0250863392*(TrueAge+200.53615212))-1*exp(0.0280890692*(TrueAge+160.2264956))-129.08189529)  #TG
          #  #X.Ymax= 1*exp(0.0251*((X.age-1)+200.1))-1*exp(0.0281*((X.age-1)+158.9))-129.1  #TG
          #X.Ymax= ((pow(paramManagement['T01'],((X.age-1)+paramManagement['tb1'])*paramManagement['k1'])-paramManagement['Lpot'])-(pow(paramManagement['T02'],((X.age-1)+paramManagement['tb2'])*paramManagement['k2'])))   # FL
          #X.Ymax= 0.85*((pow(paramManagement['T01'],((X.age-1)+paramManagement['tb1'])*paramManagement['k1'])-paramManagement['Lpot'])-(pow(paramManagement['T02'],((X.age-1)+paramManagement['tb2'])*paramManagement['k2'])))   # New FC
          #X.Ymax=0.55*((615*pow(paramManagement['T01'],X.age*0.0053))-736.9-(0.1207*pow(paramManagement['T02'],X.age*0.062)))   # FC
          X.rapportK=0.1+((TrueAge-1)/600.)
          X.Taillefinalelimbe=(1-X.rapportK)*X.Ymax
          X.Taillefinalegaine=X.Ymax*X.rapportK
          
          LED=((X.Taillefinalegaine*5)*2)-X.Ymax
          #LEDGAINE=((0.2*110*5)*2)-110
          X.Difftps=TpourY2(Seuil[X.id_plante][X.id_talle], X.Ymax,paramManagement['Jled']*LED,paramManagement['Kled']*paramManagement['Jled']*LED)-X.age#TpourY2(X.Taillefeuille+X.coupe,110, paramManagement['Jled']*LEDGAINE,paramManagement['Kled']*paramManagement['Jled']*LEDGAINE)
      
      ###### croissance ######
      LEDGAINE=((X.Taillefinalegaine*5)*2)-X.Ymax
      Accroiss=0
      #if (X.Taillegaine< Taille_finale_gaine[X.id_plante][X.id_talle][X.id_rang-1] +13):
      
      if(X.Phase=='cachee'):
        inversea=X.age-dt
        AccroissDemande=FoncCroiss(inversea+dt, X.Ymax, paramManagement['Jled']*LEDGAINE, paramManagement['Kled']*paramManagement['Jled']*LEDGAINE)-FoncCroiss(inversea, X.Ymax, paramManagement['Jled']*LEDGAINE, paramManagement['Kled']*paramManagement['Jled']*LEDGAINE)
        #Accroiss=FoncCroiss(X.age, X.Ymax, paramManagement['Jled']*LEDGAINE, paramManagement['Kled']*paramManagement['Jled']*LEDGAINE)-FoncCroiss(X.age-1, X.Ymax, paramManagement['Jled']*LEDGAINE, paramManagement['Kled']*paramManagement['Jled']*LEDGAINE)
        X.Agecroiss=X.age
      if(X.Phase=='visible'):
        AccroissDemande=(FoncCroiss(X.Agecroiss+1, X.Ymax, paramManagement['Jled']*LEDGAINE, paramManagement['Kled']*paramManagement['Jled']*LEDGAINE)-FoncCroiss(X.Agecroiss, X.Ymax, paramManagement['Jled']*LEDGAINE, paramManagement['Kled']*paramManagement['Jled']*LEDGAINE))
        X.Agecroiss=X.age+X.Difftps
      Pourcent=PourcentageFeuilGrowthRealized[X.id_plante]
      
      if(X.Phase=='mature'):
        AccroissDemande=0
      
      
      if Pourcent==1:
        Accroiss=AccroissDemande
      else:
        if AccroissDemande<=0.02:
          Accroiss=AccroissDemande
        else:
          Accroiss=DetermineAccroiss(Pourcent,X,AccroissDemande)
      
      if (X.Taillegaine>0.98*X.Taillefinalegaine and X.Taillegaine<=Taille_finale_gaine[X.id_plante][X.id_talle][X.id_rang-1] -5 and X.Phase=='visible'):
        Accroiss=1
      
      #if (X.Taillegaine>=Taille_finale_gaine[X.id_plante][X.id_talle][X.id_rang-1]  +13 and X.Phase=='visible'):
      #  Accroiss=0
      
      #taillefictive=TpourY()
      limbefictif=0.973*FoncCroiss(X.Agecroiss-1, X.Ymax, paramManagement['Jled']*LEDGAINE, paramManagement['Kled']*paramManagement['Jled']*LEDGAINE)
      
      #if X.R==0.973 and limbefictif>(0.75*X.Taillefinalelimbe):
      #  X.R=0.965
      #if X.R==0.965 and limbefictif>X.Taillefinalelimbe:
      #  X.R=0
      if ((X.Taillelimbe+X.coupe)<(0.75*X.Taillefinalelimbe)):
        X.R = 0.973
      elif (((X.Taillelimbe+X.coupe)>(0.75*X.Taillefinalelimbe)) and ((X.Taillelimbe+X.coupe)<X.Taillefinalelimbe)):
        X.R = 0.965
      else:
        X.R = 0
      
      if X.Cutstatus!='entierementcoupee': #le limbe n'est pas entierement coupe
        X.Taillefeuille=X.Taillefeuille+Accroiss
        X.Taillelimbe=X.Taillelimbe+Accroiss*X.R
        X.Taillegaine=X.Taillegaine+Accroiss*(1-X.R)
      else:
        X.Taillegaine=X.Taillegaine+Accroiss*(1-X.R)
        X.Taillefeuille=X.Taillefeuille+Accroiss*(1-X.R)
      
      if Accroiss==0:
        X.Besoinencroiss=0
        X.Phase='mature'
      
      X.biomass=BiomassFeuille(X.Taillefeuille,X.coupe,X.id_geno)
      
      # Remplissage des hauteurs d organes
      X_apex.organ_lengths_dict[X.id_rang]['sheath'] = X.Taillegaine
      X_apex.organ_lengths_dict[X.id_rang]['limb'] = X.Taillelimbe
      
      
      if X.Phase!='mature':
        if (X.Taillegaine< Taille_finale_gaine[X.id_plante][X.id_talle][X.id_rang-1] +13):
          if(X.Phase=='cachee'):
            NextAccroiss=FoncCroiss(X.age+dt, X.Ymax, paramManagement['Jled']*LEDGAINE, paramManagement['Kled']*paramManagement['Jled']*LEDGAINE)-FoncCroiss(X.age, X.Ymax, paramManagement['Jled']*LEDGAINE, paramManagement['Kled']*paramManagement['Jled']*LEDGAINE)
          else: # X.Phase=='visible'
            NextAccroiss=(FoncCroiss(X.Agecroiss+dt, X.Ymax, paramManagement['Jled']*LEDGAINE, paramManagement['Kled']*paramManagement['Jled']*LEDGAINE)-FoncCroiss(X.Agecroiss, X.Ymax, paramManagement['Jled']*LEDGAINE, paramManagement['Kled']*paramManagement['Jled']*LEDGAINE))         
        if (X.Taillegaine>0.98*X.Taillefinalegaine and X.Taillegaine<=Taille_finale_gaine[X.id_plante][X.id_talle][X.id_rang-1] -5 and X.Phase=='visible'):
          NextAccroiss=1        
        if (X.Taillegaine>=Taille_finale_gaine[X.id_plante][X.id_talle][X.id_rang-1]):
          if(X.Phase=='visible'):
            NextAccroiss=0
          else:
            NextAccroiss=0  #Ajout Thibault resoudre un bug d absence de declaration de NextAccroiss
            print('cas theoriquement improbable '+str(X.id_plante)+' '+str(X.id_talle))
        long=X.Taillefeuille+NextAccroiss
        Next_feuil=BiomassFeuille(long,X.coupe,X.id_geno)
        X.Besoinencroiss=Next_feuil-X.biomass

    else:      
      long=X.Taillefeuille
      coupe=X.coupe
      Next_feuil=paramManagement['FacBiom1']*(paramManagement['b0']*exp(paramManagement['b1']*(long+coupe)**2+paramManagement['b2']*(long+coupe))-paramManagement['b0'])*(long/(long+coupe))

      ####### Senescence #######
      
      Agesenesc = paramManagement['T0sen'] + X.Ymax * 1.5
      if X.age > Agesenesc and option_senescence:
        produce Cut() # Pour que la feuille soit vraiment coupee supprimee de la chaine, en ENTIER
        
    longueur_totale_feuille=longueur_totale_feuille+X.Taillefeuille
    
    if (X.Phase!='cachee'):
      Taillepointelineraire=ParamP[X.id_plante]['Taillepointelineraire']
      numstepsg=ceil((X.Taillegaine)/LSTEP)
      if X.Cutstatus!='entierementcoupee':
        numsteps=ceil((X.Taillefeuille)/LSTEP)
      else:
        numsteps=ceil((X.Taillegaine)/LSTEP)
      
      # Calcul surfaces limbe et gaine
      for i in range(int(numsteps)):
        if (i>=numstepsg-1):
          taille=X.Taillelimbe+X.coupe
          L0=X.Taillefinalelimbe-taille
          if ((i-numstepsg)<((taille-Taillepointelineraire)/LSTEP)):
            large=(paramManagement['CoefSecondDegreLonLar']*pow(((L0+((i-numstepsg)*LSTEP))/X.Taillefinalelimbe), 2)+paramManagement['CoefPremierDegreLonLar']*((L0+((i-numstepsg)*LSTEP))/X.Taillefinalelimbe)+paramManagement['ConstantLonLar'])*(((paramManagement['CoefDirLonLarAjust']*log(X.Ymax))-paramManagement['OrdOriLonLarAjust'])/2)
          else:
            largini=(paramManagement['CoefSecondDegreLonLar']*pow(((L0+(((i-numstepsg)-1)*LSTEP))/X.Taillefinalelimbe), 2)+paramManagement['CoefPremierDegreLonLar']*((L0+(((i-numstepsg)-1)*LSTEP))/X.Taillefinalelimbe)+paramManagement['ConstantLonLar'])*(((paramManagement['CoefDirLonLarAjust']*log(X.Ymax))-paramManagement['OrdOriLonLarAjust'])/2)
            large=largini-(((i-numstepsg)-((taille-Taillepointelineraire)/LSTEP))*((largini*LSTEP)/Taillepointelineraire))
          if(i<numstepsg-1):
            large=0.
          Surfoliaireencours[X.id_plante]=Surfoliaireencours[X.id_plante]+large*2.*LSTEP  
          X.surface_limbe += large*2.*LSTEP  # Ecriture surface seulement pour limbes emerges
      
      # Calcul surface gaine totale
      diametre_gaine = max((2 / pi) * (paramManagement['CoefDirLonLarAjust'] * log(max(X.Taillegaine * 5,1)) - paramManagement['OrdOriLonLarAjust']), 0.1)
      X.surface_gaine = X.Taillegaine * pi * diametre_gaine
      
      # Remplissage des hauteurs d organes
      X_apex.organ_lengths_dict[X.id_rang]['sheath'] = X.Taillegaine
      X_apex.organ_lengths_dict[X.id_rang]['limb'] = X.Taillelimbe
      
      produce Feuille(X, X_apex, X_phytomere)
  
  ##### Coupe des feuilles #####
  if groupe=='defoliation':
    Torsiongaine=ParamP[X.id_plante]['Torsiongaine']   
    curve=ParamP[X.id_plante]['curve']*LSTEP
    
    ### Creation de la doublure de la plante ###
    if TPS==ParamP[X.id_plante]['DCOUP']:
      nproduce Feuille(X, X_apex, X_phytomere) IN SB
      
      if (X.Phase=='cachee'):
        numsteps=(X.Taillefeuille-X.coupe)/LSTEP
        for i in range(int(numsteps)):
          PS=ParamSegFeuille(X.id_plante, X.id_talle, X.id_rang, idLong=i,hauteur=0)
          rank=X.id_rang
          if(i<(10/LSTEP)):
            nproduce  Down(Torsiongaine*pow(-1,rank)) GetPos(0,0,0) SegFeuille(PS)
          if(i>=(10/LSTEP)):
            nproduce GetPos(0,0,0) SegFeuille(PS)
      
      if (X.Phase!='cachee'):
        if X.Cutstatus!='entierementcoupee':
          numsteps=ceil((X.Taillefeuille)/LSTEP)
        else:
          numsteps=ceil((X.Taillegaine)/LSTEP)
        numstepsg=ceil((X.Taillegaine)/LSTEP)
        
        for i in range(int(numsteps)):
          PS=ParamSegFeuille(X.id_plante, X.id_talle, X.id_rang, idLong=i,hauteur=0)
          rank=X.id_rang
          if (i<numstepsg-1):
            if(i<(10/LSTEP)):
              nproduce Down(Torsiongaine*pow(-1,rank))GetPos(0,0,0)SegFeuille(PS)
            else:
              nproduce GetPos(0,0,0)SegFeuille(PS)
          
          else:
            if(i==numstepsg):
              if X.id_rang>4:
                pseudotige=max([Taille_finale_gaine[X.id_plante][X.id_talle][x] for x in range(X.id_rang-3,X.id_rang-1)])
              else:
                pseudotige=Taille_finale_gaine[X.id_plante][X.id_talle][X.id_rang-1]
              if (X.Taillegaine > pseudotige):
                nproduce Left(X.angleinsert)GetPos(0,0,0)SegFeuille(PS)
            
            if ((i>numsteps-2) and X.coupe>2):         # /* Pour avoir cicatrice au bout feuille coupees */
              if i<numstepsg:
                if X.Cutstatus=='entierementcoupee':
                  nproduce GetPos(0,0,0)SegFeuille(PS)
                else:
                  nproduce RollR(0)Left(curve)GetPos(0,0,0)SegFeuille(PS)
              else:
                nproduce RollR(0)Left(curve)GetPos(0,0,0)SegFeuille(PS)
            
            if(X.id_rang==1 and X.id_talle>0):
              if (i>(X.TailleEmergence-2)/LSTEP):
                nproduce RollR(0)Left(curve)GetPos(0,0,0)SegFeuille(PS)
              
              if (i<(X.TailleEmergence-2)/LSTEP):
                if(i<(10/LSTEP)):
                  nproduce  Down(Torsiongaine*pow(-1,rank))GetPos(0,0,0)SegFeuille(PS)
                else:
                  nproduce GetPos(0,0,0)SegFeuille(PS)
            
            else:
              if X.id_rang>4:
                pseudotige=max([Taille_finale_gaine[X.id_plante][X.id_talle][x] for x in range(X.id_rang-3,X.id_rang-1)])
              else:
                pseudotige=Taille_finale_gaine[X.id_plante][X.id_talle][X.id_rang-1]
              
              if (i>pseudotige/LSTEP):
                if i<numstepsg:
                  if X.Cutstatus=='entierementcoupee':
                    nproduce GetPos(0,0,0)SegFeuille(PS)
                  else:
                    nproduce RollR(0)Left(curve)GetPos(0,0,0)SegFeuille(PS)
                else:
                  nproduce RollR(0)Left(curve)GetPos(0,0,0)SegFeuille(PS)
              
              if (i<=pseudotige/LSTEP):
                if(i<(10/LSTEP)):
                  nproduce  Down(Torsiongaine*pow(-1,rank))GetPos(0,0,0)SegFeuille(PS)
                else:
                  nproduce GetPos(0,0,0)SegFeuille(PS)
      produce IN EB
    
    ### Realisation de la coupe ###
    elif TPS==ParamP[X.id_plante]['DCOUP']+0.5:
        segments_feuille=[x for x in les_segments_feuilles if (x[0].id_plante==X.id_plante and x[0].id_talle==X.id_talle and x[0].id_rang==X.id_rang)]
        longcoupee=LongueurFeuilleCoupee(segments_feuille,X.id_plante)
        if longcoupee!=-1:
          X.coupe=X.Taillefeuille-longcoupee
          X.Taillefeuille=longcoupee
          if X.Taillefeuille<X.Taillegaine:
            X.Taillegaine=X.Taillefeuille
            X.Taillelimbe=0
            X.Cutstatus='entierementcoupee'
          else:
            X.Taillelimbe=X.Taillefeuille-X.Taillegaine
            X.Cutstatus='partiellementcoupee'
        
        # Remplissage des hauteurs d organes 
        X_apex.organ_lengths_dict[X.id_rang]['sheath'] = X.Taillegaine
        X_apex.organ_lengths_dict[X.id_rang]['limb'] = X.Taillelimbe
        
        produce Feuille(X, X_apex, X_phytomere)
    
    ### Recalcul de la biomasse foliaire ###
    elif TPS==ParamP[X.id_plante]['DCOUP']+0.75:
      if X.Taillegaine*1.>Seuil[X.id_plante][X.id_talle]:
        Seuil[X.id_plante][X.id_talle]=X.Taillegaine
      
      Taille_finale_gaine[X.id_plante][X.id_talle][X.id_rang]=X.Taillegaine
      
      if X.id_rang==1 and X.id_talle>0 and X.topology!=(0,0):  # Premiere feuille de chaque talle sauf brin maitre et talle coleoptile
        feuille_ref = les_feuilles[(les_feuilles['Plante'] == X.id_plante) & (les_feuilles['Topology'] == X.topology[:-1]) & (les_feuilles['id_rang'] == max(1, X.topology[-1]))].iloc[0]['ObjetOrgane']    # Feuille axillante de l'ordre pr�c�dent (le max sert a traiter les cas des 1ers rangs)
        Seuil[X.id_plante][X.id_talle]=max(Seuil[X.id_plante][X.id_talle], feuille_ref.Taillegaine)
      X.biomass=BiomassFeuille(X.Taillefeuille,X.coupe,X.id_geno)
    else:
      # Remplissage des hauteurs d organes 
      X_apex.organ_lengths_dict[X.id_rang]['sheath'] = X.Taillegaine
      X_apex.organ_lengths_dict[X.id_rang]['limb'] = X.Taillelimbe
      produce Feuille(X, X_apex, X_phytomere)


GetPos(a,b,c):
  for ID in range(nb_plantes):
    if TPS==ParamP[ID]['DCOUP']+0.5:
      produce


SegFeuille(X):
  if TPS==ParamP[X.id_plante]['DCOUP']+0.75:
    produce


Entrenoeud(X_EN, X_AP, X_F, X_phytomere):
  if (X_EN.internode_type != 'long_internode' and X_AP.phenological_state == 'reproductive' and X_F.Phase != 'mature'):
    X_EN.internode_type = 'long_internode'
  if (X_F.Phase == 'mature' and X_EN.internode_type == 'long_internode' and X_EN.length < X_F.Taillefinalegaine + 5):              # condition pour arreter la croissance des entrenoeuds
    X_EN.length += 5    # Remplissage des hauteurs d organes
    X_AP.organ_lengths_dict[X_EN.id_rang]['internode'] = X_EN.length
    #produce Entrenoeud(X_EN, X_AP, X_F, X_phytomere)
  elif (X_F.Phase == 'mature' and ((X_EN.internode_type == 'long_internode' and X_EN.length >= X_F.Taillefinalegaine + 5) or X_EN.internode_type == 'short_internode')):
    # Remplissage des hauteurs d organes
    X_AP.organ_lengths_dict[X_EN.id_rang]['internode'] = X_EN.length
    #produce Entrenoeud(X_EN, X_AP, X_F, X_phytomere)


apex(X):
  global les_feuilles, current_day, meteo, df_induction, df_organ_lengths, tiller_appearance
  
  if X.day < current_day:
    X.day = current_day
    date = meteo.date[meteo.experimental_day == current_day].iloc[0]
    daily_temperature = meteo.mean_temperature[meteo.experimental_day == current_day].iloc[0]
    daily_daylength = meteo.daylength[meteo.experimental_day == current_day].iloc[0]
    
    for phytomere_rank in X.organ_lengths_dict.keys():
      for organ in X.organ_lengths_dict[phytomere_rank].keys():
        df_organ_lengths = df_organ_lengths.append({'GDD': TPS, 'Date': date, 'Site': site, 'Day': current_day, 'Id_plante': X.id_plante, 'Id_talle': X.id_talle, 'Id_rang': phytomere_rank, 'Organ': organ, 'Length': X.organ_lengths_dict[phytomere_rank][organ]}, ignore_index = True)

    # ------------------------------------------------------------------------------------------------
    # ------------------------- Management of the flowering state of the apex ------------------------
    # ------------------------------------------------------------------------------------------------
    # The apex parameters are updated at the end of each day.
    # A unique temperature and a daylength are associated to each day
    # 'primary_induction_index' is a cumulated sum of a daily 'primary_induction_increment' calculated
    #                        by 'flowering_functions.py' using daily mean temperature
    # 'secondary_induction_index' is a cumulated sum of a daily 'secondary_induction_increment'
    #                     calculated by 'flowering_functions.py' using daily mean temperature
    # When the primary induction is completed (index>1) and the apex has created 2 leaves (1 emerged) it become competent to the secondary
    # induction on the next day.
    # When the secondary induction is completed (index>1), the apex become reproductive.
    # The two inductions are irreversible.
    # ------------------------------------------------------------------------------------------------

    if option_floraison == True:
      if X.phenological_state == 'vegetative':
        X.primary_induction_index += flowering_model.vernalisation_function(daily_temperature,X.id_plante)
        
        if X.primary_induction_index >= 1:
          X.phenological_state = 'vernalized'
      
      elif (X.phenological_state == 'vernalized' and X.total_created_leaves > 1):
        print('vernalized')
        X.secondary_induction_index += flowering_model.photoperiod_induction_function(daily_daylength,X.id_plante)
        if X.secondary_induction_index >= 1:
          X.phenological_state = 'reproductive'
          print('reproductive')

    df_induction = df_induction.append({'GDD': TPS, 'Date': date, 'Site': site, 'Day': current_day, 'Daily_mean_temperature': daily_temperature, 'Daily_daylength': daily_daylength, 'Id_plante': X.id_plante, 'Id_talle': X.id_talle, 'topology':X.topology, 'Leaf_produced': X.total_created_leaves, 'Primordia_on_apex': X.primordia_number, 'Spikelet_number': X.spikelet_created, 'Vernalisation_rate': X.primary_induction_index, 'Secondary_induction_rate': X.secondary_induction_index, 'Heading_date': X.heading_date}, ignore_index = True)


  if groupe=='croissance':     
    if (X.phenological_state == 'vegetative' or X.phenological_state == 'vernalized' or (X.phenological_state == 'reproductive' and (X.final_leaf_number is None or X.total_created_leaves < X.final_leaf_number))):
      feuille_ref = les_feuilles[(les_feuilles['Plante'] == X.id_plante) & (les_feuilles['id_talle'] == X.id_talle) & (les_feuilles['id_rang'] == X.id_rang)].iloc[0]['ObjetOrgane']
      if X.retard==2:
        #Seuil[X.id_plante][X.id_talle]=Seuil[X.id_plante][X.id_talle] * 1.15
        Taille_finale_gaine[X.id_plante][X.id_talle].append(5.5)
        YP=ParamPhytomere(X.id_plante,X.id_talle,X.id_rang+1, topology=X.topology)
        YF=ParamFeuille(age=0,Agecroiss=0,Taillefeuille=0,id_plante=X.id_plante,id_talle=X.id_talle,id_rang=X.id_rang+1,topology=X.topology, Ymax=Premiecroiss[X.id_plante],Taillefinalelimbe=0.8*Premiecroiss[X.id_plante],Taillefinalegaine=0.2*Premiecroiss[X.id_plante], id_geno=X.id_geno)
        Yb=ParambourgeonRoot(X.id_plante,X.id_talle,X.id_rang+1, id_geno=X.id_geno)
        YAT=ParamApexTal(id_plante = X.id_plante, id_talle = X.id_talle, id_rang = X.id_rang+1, topology=X.topology, id_geno=X.id_geno)
        YINT=ParamEntrenoeud(X.id_plante, X.id_talle, X.id_rang+1, topology=X.topology)      # AJOUT SIMON
        X.id_rang += 1
        X.retard = 0
        X.total_created_leaves += 1
        X.organ_lengths_dict[YP.id_rang] = {'limb': YF.Taillelimbe, 'sheath': YF.Taillegaine, 'internode': YINT.length}
        if X.appearance_date == None and X.total_emerged_leaves > 0:
          X.appearance_date = TPS
          tiller_appearance = tiller_appearance.append(pd.DataFrame({'id_plante': [X.id_plante], 'id_talle': [X.id_talle], 'appearance_date': [X.appearance_date]}))
        
        
        
        # -------------------------------------------------------------------------------------------------
        # ------------------------------------ Number of primodia -----------------------------------------
        # -------------------------------------------------------------------------------------------------
        # Description :
        # Two relations exist between primordia emission and leaf appearance 
        # - 'coeff_primordia_emission_vegetative' before secondary induction
        # - 'coeff_primordia_emission_reproductive' during and after secondary induction
        # When secondary induction is completed, all existing primodia will become leaves
        # When flag leaf is produced (emergence of the penultimate leaf), apex stop to produce spikelets
        # -------------------------------------------------------------------------------------------------
        if X.secondary_induction_index == 0:
          X.primordia_number += flowering_model.param.coeff_primordia_emission_vegetative[X.id_plante] - 1    # 1 correspond to the new leaf produced
        elif X.phenological_state == 'vernalized' and 0 < X.secondary_induction_index:
          X.primordia_number += flowering_model.param.coeff_primordia_emission_reproductive[X.id_plante] - 1
        elif X.phenological_state == 'reproductive' or X.secondary_induction_index >= 1:
          if X.final_leaf_number is None:
            X.final_leaf_number = X.total_created_leaves + X.primordia_number
          X.primordia_number += flowering_model.param.coeff_primordia_emission_reproductive[X.id_plante] - 1
        produce RollR(180) phytomere(YP, X) bourgeonRoot(Yb, YINT) ApexTal(YAT) Entrenoeud(YINT, X, YF, YP) FLW SB Feuille(YF, X, YP) FLW EB apex(X)
        
      elif X.retard==1:
        X.retard=2
        print('RETARD_1')
        produce apex(X)
      elif feuille_ref and abs(Seuil[X.id_plante][X.id_talle]-feuille_ref.Taillefeuille)<2: #Si |Seuil-Taillefeuille| <2mm
        X.retard=1
        print('RETARD_0')
        produce apex(X)

    if (X.phenological_state == 'reproductive' and X.total_created_leaves == X.final_leaf_number):
      if (X.final_spikelet_number is None):
        X.final_spikelet_number = X.primordia_number
        
      if (X.spikelet_created < X.final_spikelet_number):
        YEntrenoeudEpi = ParamEntrenoeudEpi(id_plante = X.id_plante, id_talle = X.id_talle, id_rang = X.id_rang + 1, topology=X.topology, long_entrenoeud = 0)      # ATTENTION il faudra donner une orientation au premier epillet
        YEpillet = ParamEpillet(id_plante = X.id_plante, id_talle = X.id_talle, id_rang = X.id_rang + 1, topology=X.topology, long_epillet = 0)
        X.spikelet_created += 1
        X.organ_lengths_dict[X.id_rang +1] = {'internode' : YEntrenoeudEpi.long_entrenoeud, 'spikelet' : YEpillet.long_epillet}
        X.id_rang += 1
        produce RollR(180) EntrenoeudEpi(YEntrenoeudEpi, X) SB +(20) Epillet(YEpillet, X) EB apex(X)   
        
      elif (X.phenological_state == 'reproductive' and X.spikelet_created == X.final_spikelet_number):
        # -------------------------------------------------------------------------------------------------
        # ------------------------------- Determination of heading date -----------------------------------
        # -------------------------------------------------------------------------------------------------
        # Description :
        # Heading occurs when the terminal spikelet of the spike emerge out of the highest ligule of its   
        # tiller. Height of the last spikelet is the sum of the spike length and the lengths of all the 
        # internodes of the tiller. Height of the highest ligule is the sum of the length of the sheath 
        # of the associted leaf and the lengths of all internodes located under that leaf.
        # The values used for the calculation are stored in 'organ_lengths_dict'
        # -------------------------------------------------------------------------------------------------
        
        highest_ligule = {'id_rang': 999, 'height': 0}
        for phytomere_rank in [t for t in X.organ_lengths_dict.keys() if t <= X.final_leaf_number]:
          height = X.organ_lengths_dict[phytomere_rank]['sheath']
          for i in [t for t in X.organ_lengths_dict.keys() if t <= phytomere_rank]:
            height += X.organ_lengths_dict[i]['internode']
          if height >= highest_ligule['height']:
            highest_ligule = {'id_rang': phytomere_rank, 'height': height}

        X.terminal_spikelet_height = X.organ_lengths_dict[max(X.organ_lengths_dict.keys())]['spikelet']
        for phytomere_rank in X.organ_lengths_dict.keys():
          X.terminal_spikelet_height += X.organ_lengths_dict[phytomere_rank]['internode']

        if (X.heading_date == 0 and X.terminal_spikelet_height > highest_ligule['height']):
          X.heading_date = current_day
          
        produce apex(X)
      
  if groupe=='defoliation':
    produce apex(X)


ApexTal(X):
  global les_feuilles, rapportS9_SSol_dict
  if option_tallage == True:
    if groupe=='croissance':
      feuille_ref = les_feuilles[(les_feuilles['Plante'] == X.id_plante) & (les_feuilles['id_talle'] == X.id_talle) & (les_feuilles['id_rang'] == X.id_rang+2)]['ObjetOrgane']  # Coordination demarrage ApexTal avec feuille n+2
      if not feuille_ref.empty:
        seuil=max(Taille_finale_gaine[X.id_plante][X.id_talle][X.id_rang-1], 5.5)
        
        if X.id_rang==0 and X.id_talle==0:
          produce F(0)
        Sitefillingproba = random.uniform(0, ParamP[X.id_plante]['STOPTALLAGE']) #Besoin de choisir des valeurs de tallage a laquelle arreter
        rapportS9_SSol = rapportS9_SSol_dict[X.id_plante]
        if (rapportS9_SSol<Sitefillingproba): #Pour la gestoin du site filling : plus la surface augmente et plus la probabilite de faire une talle diminue
          if (rapportS9_SSol<=ParamP[X.id_plante]['SENSETALLAGE']):
            nb_talle[X.id_plante]=nb_talle[X.id_plante]+1
            Seuil[X.id_plante].append(seuil)
            Taille_finale_gaine[X.id_plante].append([5.5,5.5])
            tiller_topology = X.topology + (X.id_rang - 1,)  # Garde info topologique du phyto duquel la talle emergera. La talle de coleoptile sera (0,0)
            YP=ParamPhytomere(X.id_plante,nb_talle[X.id_plante],id_rang=1, topology=tiller_topology)
            YF=ParamFeuille(age=0,Agecroiss=0,Taillefeuille=0,id_plante=X.id_plante,id_talle=nb_talle[X.id_plante],id_rang=1, topology=tiller_topology, Ymax=Premiecroiss[X.id_plante],Taillefinalelimbe=0.8*Premiecroiss[X.id_plante],Taillefinalegaine=0.2*Premiecroiss[X.id_plante])
            Yb=ParambourgeonRoot(X.id_plante,nb_talle[X.id_plante],id_rang=1)
            YAT=ParamApexTal(X.id_plante,nb_talle[X.id_plante],id_rang=1, topology=tiller_topology)
            YA=ParamApex(X.id_plante,nb_talle[X.id_plante],id_rang=1, topology=tiller_topology)
            YINT=ParamEntrenoeud(X.id_plante,id_talle=0,id_rang=1, topology=tiller_topology)      # AJOUT SIMON
            
            YA.organ_lengths_dict = {YP.id_rang: {'limb': YF.Taillelimbe, 'sheath': YF.Taillegaine, 'internode': YINT.length}}
            produce SB phytomere(YP, YA) RollR(95) GetHead(0, 0, 0) bourgeonRoot(Yb, YINT) ApexTal(YAT) Entrenoeud(YINT, YA, YF, YP) FLW SB Feuille(YF, YA, YP) FLW EB apex(YA) EB
          
          if (rapportS9_SSol>ParamP[X.id_plante]['SENSETALLAGE']):
            deuxiemede = random.uniform(0, 5)
            if (deuxiemede <= 2): #  Proba de 0.4
              nb_talle[X.id_plante]=nb_talle[X.id_plante]+1
              Seuil[X.id_plante].append(seuil)
              Taille_finale_gaine[X.id_plante].append([5.5,5.5])
              tiller_topology = X.topology + (X.id_rang - 1,)
              YP=ParamPhytomere(X.id_plante,nb_talle[X.id_plante],id_rang=1, topology=tiller_topology)
              YF=ParamFeuille(age=0,Agecroiss=0,Taillefeuille=0,id_plante=X.id_plante,id_talle=nb_talle[X.id_plante],id_rang=1, topology=tiller_topology, Ymax=Premiecroiss[X.id_plante],Taillefinalelimbe=0.8*Premiecroiss[X.id_plante],Taillefinalegaine=0.2*Premiecroiss[X.id_plante])
              Yb=ParambourgeonRoot(X.id_plante,nb_talle[X.id_plante],id_rang=1)
              YAT=ParamApexTal(X.id_plante,nb_talle[X.id_plante],id_rang=1, topology=tiller_topology)
              YA=ParamApex(X.id_plante,nb_talle[X.id_plante],id_rang=1, topology=tiller_topology)
              YINT=ParamEntrenoeud(X.id_plante,id_talle=0,id_rang=1, topology=tiller_topology)      # AJOUT SIMON
              
              YA.organ_lengths_dict = {YP.id_rang: {'limb': YF.Taillelimbe, 'sheath': YF.Taillegaine, 'internode': YINT.length}}
              produce SB phytomere(YP, YA) RollR(95) GetHead(0, 0, 0) bourgeonRoot(Yb, YINT) ApexTal(YAT) Entrenoeud(YINT, YA, YF, YP) FLW SB Feuille(YF, YA, YP) FLW EB apex(YA) EB
            else:
              produce
        else:
          produce
      else:
        produce ApexTal(X)
    if groupe=='defoliation':
      produce ApexTal(X)
  
  else:
    produce ApexTal(X)


EntrenoeudEpi(X, X_apex):
  if X.id_rang == X_apex.final_leaf_number +1:                     # Compter les entrenoeuds de l epi et appliquer une regle de croissance differente pour le pedoncule
    if X.long_entrenoeud < 100:
      X.long_entrenoeud += 0.2
  else:
    if X.long_entrenoeud < 5:            # PARAMETRE
      X.long_entrenoeud += 0.005            # PARAMETRE
  # Remplissage des longueurs d organes
  X_apex.organ_lengths_dict[X.id_rang]['internode'] = X.long_entrenoeud
  produce EntrenoeudEpi(X, X_apex)


Epillet(X, X_apex):
  if X.long_epillet < 5:                 # PARAMETRE
    X.long_epillet += 0.2               # PARAMETRE
  # Remplissage des longueurs d organes
  X_apex.organ_lengths_dict[X.id_rang]['spikelet'] = X.long_epillet
  produce Epillet(X, X_apex)


racine(X):
  global les_racines,les_feuilles
  if OptionRacine=='SansRacines':
    produce *
  else:
    if X.axe_arret==0:
      feuille_test=[x for x in les_feuilles if (x.id_plante==X.id_plante and x.id_talle==X.id_talle and x.id_rang==X.feuil_ref+6)][0]
      if feuille_test!=[] and feuille_test.Phase!='cachee':
        X.axe_arret=1
    
    elif X.lateral_arret==0:
      feuille_test = [x for x in les_feuilles if (x.id_plante==X.id_plante and x.id_talle==X.id_talle and x.id_rang==X.feuil_ref+7)][0]
      if feuille_test!=[] and feuille_test.Phase!='cachee':
        X.lateral_arret=1


bourgeonRoot(X, Y_EN):
  global num_pointe,les_feuilles,Biomasse_aerienne,groupe 
  
  if OptionRacine=='SansRacines':
    produce *
  
  else:
    if Y_EN.length > 0:
      produce *
  
    else:
      if groupe=='croissance':
        feuille_du_phytomere = [x for x in les_feuilles if (x.id_plante==X.id_plante and x.id_talle==X.id_talle and x.id_rang==X.id_rang)][0]
        ordre=Order(Complex(feuille_du_phytomere)) #ordre de la talle, TODO: ordre a activer quand mtg
        
        
        if X.nb_prod_root==0:
          feuille_reference = [x for x in les_feuilles if (x.id_plante==X.id_plante and x.id_talle==X.id_talle and x.id_rang==X.id_rang+ordre)][0]
          if feuille_reference!=[] and feuille_reference.Phase!='cachee':
            num_pointe=num_pointe+1
            #if Biomasse_aerienne<0.1:
            #  if les_diametres==[]:
            #    Diameter=ParamP[X.id_plante]['P_diamMax']	#random.normalvariate(0.59,0.11)       #(2.3*Biomasse_aerienne+0.33)
            #  else:
            #    nb=len(les_diametres)+1  
            #    Diameter=P_diamMax	#random.normalvariate(0.59,0.11)         #nb*(2.3*Biomasse_aerienne+0.33-(sum(les_diametres)/nb))
            #else:
            #  nb=len(les_diametres)+1
            #  Diameter=P_diamMax		#random.normalvariate(0.59,0.11)             #nb*(0.56-(sum(les_diametres)/nb))
            
            if Biomasse_aerienne[X.id_plante]<paramManagement['SBDmax']:
              Diameter=paramManagement['Dmax']*(1+((paramManagement['SBDmax']-Biomasse_aerienne[X.id_plante])/paramManagement['SBDmax']))*((Biomasse_aerienne[X.id_plante]+paramManagement['SBDmax'])/(2*paramManagement['SBDmax']))**2
            else:
              Diameter=paramManagement['Dmax']
            
            les_diametres.append(Diameter)
            X.nb_prod_root=1
            Y=pte(id_pointe=num_pointe,id_plante=X.id_plante,age=0,diametre=Diameter,Tortue=np.array([[0.,0.,-1],[0.,1,0],[-1.,0.,0.]]),isaxe=True)
            Y2=ParamRacine(age=0,id_plante=X.id_plante,id_talle=X.id_talle,id_rang=X.id_rang,feuil_ref=X.id_rang+ordre)
            produce bourgeonRoot(X) FLW SB() racine(Y2) SetHead(0.,0.,-1.,-1.,0.,0.) tip(Y) FLW EB()
          else:
            produce bourgeonRoot(X, Y_EN)
        
        elif X.nb_prod_root==1:
          if ordre==0:
            feuille_reference=[x for x in les_feuilles if (x.id_plante==X.id_plante and x.id_talle==X.id_talle and x.id_rang==X.id_rang+1)]
          else:
            feuille_reference=[x for x in les_feuilles if (x.id_plante==X.id_plante and x.id_talle==X.id_talle and x.id_rang==X.id_rang+ordre+1)][0]
          if feuille_reference!=[] and feuille_reference.Phase!='cachee':
            num_pointe=num_pointe+1
            #if Biomasse_aerienne<0.1:
            #  if les_diametres==[]:
            #    Diameter=P_diamMax#random.normalvariate(0.59,0.11)          #(2.3*Biomasse_aerienne+0.33)
            #  else:
            #      nb=len(les_diametres)+1  
            #    Diameter=P_diamMax#random.normalvariate(0.59,0.11)            #nb*(2.3*Biomasse_aerienne+0.33-(sum(les_diametres)/nb))
            #else:
            #  nb=len(les_diametres)+1
            #  Diameter=P_diamMax#random.normalvariate(0.59,0.11)             #nb*(0.56-(sum(les_diametres)/nb))
            
            if Biomasse_aerienne[X.id_plante]<paramManagement['SBDmax']:
              Diameter=paramManagement['Dmax']*(1+((paramManagement['SBDmax']-Biomasse_aerienne[X.id_plante])/paramManagement['SBDmax']))*((Biomasse_aerienne[X.id_plante]+paramManagement['SBDmax'])/(2*paramManagement['SBDmax']))**2
            else:
              Diameter=paramManagement['Dmax']
            #Diameter=0.58
            
            les_diametres.append(Diameter)
            X.nb_prod_root=2
            Y=pte(id_pointe=num_pointe,id_plante=X.id_plante,age=0,diametre=Diameter,Tortue=np.array([[0.,0.,-1],[0.,1,0],[-1.,0.,0.]]),isaxe=True)
            Y2=ParamRacine(age=0,id_plante=X.id_plante,id_talle=X.id_talle,id_rang=X.id_rang,feuil_ref=X.id_rang+ordre+1)
            produce FLW SB() racine(Y2)  SetHead(0.,0.,-1.,-1.,0.,0.) tip(Y) FLW EB()
          else:
            produce bourgeonRoot(X, Y_EN)
        
        #else:
        #  if X.nb_prod_root==0:
        #    feuille_reference=[x for x in les_feuilles if (mtg.property('ParamFeuille').get(x).id_plante==X.id_plante and mtg.property('ParamFeuille').get(x).id_talle==X.id_talle and mtg.property('ParamFeuille').get(x).id_rang==X.id_rang+(ordre-1))]
        #    if feuille_reference!=[] and mtg.property('ParamFeuille').get(feuille_reference[0]).Phase!='cachee':
        #      num_pointe=num_pointe+1
        #      #if Biomasse_aerienne<0.1:
        #      #  if les_diametres==[]:
        #      #    Diameter=P_diamMax#random.normalvariate(0.59,0.11)          #(2.3*Biomasse_aerienne+0.33)
        #      #  else:
        #      #    nb=len(les_diametres)+1  
        #      #    Diameter=P_diamMax#random.normalvariate(0.59,0.11)           #nb*(2.3*Biomasse_aerienne+0.33-(sum(les_diametres)/nb))
        #      #else:
        #      #  nb=len(les_diametres)+1
        #      #  Diameter=P_diamMax#random.normalvariate(0.59,0.11)            #nb*(0.56-(sum(les_diametres)/nb))
        #      
        #      if Biomasse_aerienne[X.id_plante]<paramManagement['SBDmax']:
        #        Diameter=paramManagement['Dmax']*(1+((paramManagement['SBDmax']-Biomasse_aerienne[X.id_plante])/paramManagement['SBDmax']))*((Biomasse_aerienne[X.id_plante]+paramManagement['SBDmax'])/(2*paramManagement['SBDmax']))**2
        #      else:
        #        Diameter=paramManagement['Dmax']
        #      
        #      les_diametres.append(Diameter)
        #      X.nb_prod_root=1
        #      Y=pte(id_pointe=num_pointe,id_plante=X.id_plante,age=0,diametre=Diameter,Tortue=np.array([[0.,0.,-1],[0.,1,0],[-1.,0.,0.]]))
        #      Y2=ParamRacine(age=0,id_plante=X.id_plante,id_talle=X.id_talle,id_rang=X.id_rang)
        #      produce bourgeonRoot(X) FLW SB() racine(Y2)  SetHead(0.,0.,-1.,-1.,0.,0.) tip(Y)  FLW EB()
        #    else:
        #      produce bourgeonRoot(X)
        #      
        #  elif X.nb_prod_root==1:
        #    feuille_reference=[x for x in les_feuilles if (mtg.property('ParamFeuille').get(x).id_plante==X.id_plante and mtg.property('ParamFeuille').get(x).id_talle==X.id_talle and mtg.property('ParamFeuille').get(x).id_rang==X.id_rang+ordre)]
        #    if feuille_reference!=[] and mtg.property('ParamFeuille').get(feuille_reference[0]).Phase!='cachee':
        #      num_pointe=num_pointe+1
        #      #if Biomasse_aerienne<0.1:
        #      #  if les_diametres==[]:
        #      #    Diameter=P_diamMax#random.normalvariate(0.59,0.11)          #(2.3*Biomasse_aerienne+0.33)
        #      #  else:
        #      #    nb=len(les_diametres)+1  
        #      #    Diameter=P_diamMax#random.normalvariate(0.59,0.11)            #nb*(2.3*Biomasse_aerienne+0.33-(sum(les_diametres)/nb))
        #      #else:
        #      #  nb=len(les_diametres)+1
        #      #  Diameter=P_diamMax#random.normalvariate(0.59,0.11)             #nb*(0.56-(sum(les_diametres)/nb))
        #      
        #      if Biomasse_aerienne[X.id_plante]<paramManagement['SBDmax']:
        #        Diameter=paramManagement['Dmax']*(1+((paramManagement['SBDmax']-Biomasse_aerienne[X.id_plante])/paramManagement['SBDmax']))*((Biomasse_aerienne[X.id_plante]+paramManagement['SBDmax'])/(2*paramManagement['SBDmax']))**2
        #      else:
        #        Diameter=paramManagement['Dmax']
        #      
        #      
        #      les_diametres.append(Diameter)
        #      X.nb_prod_root=2
        #      Y=pte(id_pointe=num_pointe,id_plante=X.id_plante,age=0,diametre=Diameter,Tortue=np.array([[0.,0.,-1],[0.,1,0],[-1.,0.,0.]]))
        #      Y2=ParamRacine(age=0,id_plante=X.id_plante,id_talle=X.id_talle,id_rang=X.id_rang)
        #      produce FLW SB() racine(Y2)  SetHead(0.,0.,-1.,-1.,0.,0.) tip(Y) FLW EB()
        #    else:
        #      produce bourgeonRoot(X)
        
        if X.nb_prod_root==2:
          produce
        
        #if ordre<=1:
        #  feuille_reference=feuille_du_phytomere
        #  if mtg.property('ParamFeuille').get(feuille_reference).Phase!='cachee':
        #    num_pointe=num_pointe+1
        #    if Biomasse_aerienne<0.1:
        #      if les_diametres==[]:
        #        Diameter=P_diamMax       #(2.3*Biomasse_aerienne+0.33)
        #      else:
        #        nb=len(les_diametres)+1
        #        Diameter=P_diamMax         #nb*(2.3*Biomasse_aerienne+0.33-(sum(les_diametres)/nb))
        #    else:
        #      nb=len(les_diametres)+1
        #      Diameter=P_diamMax          #nb*(0.56-(sum(les_diametres)/nb))
        #    les_diametres.append(Diameter)
        #    Y=pte(id_pointe=num_pointe,age=0,diametre=Diameter,Tortue=np.array([[0.,0.,-1],[0.,1,0],[-1.,0.,0.]]))
        #    Y2=ParamRacine(age=0,id_plante=X.id_plante,id_talle=X.id_talle,id_rang=X.id_rang)
        #    produce FLW SB() racine(Y2) IN SB() SetHead(0.,0.,-1.,-1.,0.,0.) tip(Y) IN EB() FLW EB()
        #  else:
        #    produce bourgeonRoot(X)
        #else:
        #  feuille_reference=[x for x in les_feuilles if (mtg.property('ParamFeuille').get(x).id_plante==X.id_plante and mtg.property('ParamFeuille').get(x).id_talle==X.id_talle and mtg.property('ParamFeuille').get(x).id_rang==X.id_rang+(ordre-1))]
        #  if feuille_reference!=[] and mtg.property('ParamFeuille').get(feuille_reference[0]).Phase!='cachee':
        #    num_pointe=num_pointe+1
        #    
        #    if Biomasse_aerienne<0.1:
        #      nb=len(les_diametres)+1
        #      Diameter=P_diamMax   #nb*(2.3*Biomasse_aerienne+0.33-(sum(les_diametres)/nb))#*0.9  
        #    else:
        #      nb=len(les_diametres)+1
        #      Diameter=P_diamMax   #nb*(0.56-(sum(les_diametres)/nb))#*0.9  
        #    les_diametres.append(Diameter)
        #    Y=pte(id_pointe=num_pointe,age=0,diametre=Diameter,Tortue=np.array([[0.,0.,-1],[0.,1,0],[-1.,0.,0.]]))
        #    Y2=ParamRacine(age=0,id_plante=X.id_plante,id_talle=X.id_talle,id_rang=X.id_rang)
        #    produce FLW SB() racine(Y2) IN SB() SetHead(0.,0.,-1.,-1.,0.,0.) tip(Y) IN EB() FLW EB()
        #  else:
        #    produce bourgeonRoot(X)
        #  produce bourgeonRoot(X)
      
      if groupe=='defoliation':
        produce bourgeonRoot(X, Y_EN)


tip(X):
  global mtg,num_primordium,les_pointes,RootPotentialNewBiomass,PourcentageRootGrowthRealized,groupe,TPS_expe
  if OptionRacine=='SansRacines':
      produce *
  else:
    if groupe=='croissance' and not X.arretee:
      X.age=X.age+dt
      for x in les_pointes:
        if x[0]==X.id_pointe:
          vertex_pointe=x[1]
          break
      
      vertex_racine=Complex(vertex_pointe)
      if X.isaxe and mtg.property('ParamRacine').get(vertex_racine).axe_arret==1:
        X.arretee=True
      elif not X.isaxe and mtg.property('ParamRacine').get(vertex_racine).lateral_arret==1:
        X.arretee=True
      
      #plante=Complex(vertex_pointe,2)
      pourcentage=PourcentageRootGrowthRealized[X.id_plante]
      
      if X.arretee==False and X.senile==False and X.diametre>ParamP[X.id_plante]['P_diamMin']:
        profondeur=X.posO[2]
        PotentielCroissance=CroissanceRacine2(X,profondeur)
        RootPotentialNewBiomass[X.id_plante]+=ParamP[X.id_plante]['P_RootMasseVolumique']*(pi*(X.diametre/2)*(X.diametre/2)*PotentielCroissance)
        elongation=PotentielCroissance*pourcentage
        X.longueur=X.longueur+elongation
        distInterRamif=ParamP[X.id_plante]['P_distRamif'] * float(Sol[Couche(X.id_plante,profondeur)][1])
        init=1
        
        while X.longueur > distInterRamif:
          (X.Tortue,X.posO)=Gravitropisme(X.id_plante,vertex_pointe,X.segment,profondeur,ParamP[X.id_plante]['longSegNorm'],init)
          if X.segment==0:
            X.segment=1
          
          Z=seg(TPS,X.diametre,distInterRamif,X.id_pointe)
          nproduce SetHead(X.Tortue[0][0],X.Tortue[1][0],X.Tortue[2][0],X.Tortue[0][2],X.Tortue[1][2],X.Tortue[2][2])segment(Z)
          
          diam=tireDiamPointeFille(X.id_plante,X.diametre)
          num_primordium=num_primordium+1
          param=primord(id_plante=X.id_plante, id_primord=num_primordium,age=0,diametre=diam,Tortue=X.Tortue,id_pointe_axe=X.id_pointe,posO=X.posO)
          nproduce Site(param)
          
          X.longueur=X.longueur-distInterRamif
          init=0
      
      #vertex_axe=Axis(vertex_pointe)
      #if X.senile==False and TPS>10 and X.arretee==False:
      #  racine=Complex(vertex_pointe)
      #  elements=Components(racine)
      #  if elements[len(elements)-1]==vertex_pointe: #Pointe d'un axe
      #    phyto=Complex(racine)
      #    ordre=Order(phyto)
      #    feuille_associe=[x for x in Components(phyto) if Class(x)=='F'][0]
      #    if ordre==0:
      #      comp=0
      #    else:
      #      comp=ordre-1
      #    #feuille_reference=[x for x in les_feuilles if (mtg.property('ParamFeuille').get(x).id_plante==mtg.property('ParamFeuille').get(feuille_associe).id_plante and mtg.property('ParamFeuille') .get(x).id_talle==mtg.property('ParamFeuille').get(feuille_associe).id_talle and mtg.property('ParamFeuille').get(x).id_rang==mtg.property('ParamFeuille').get(feuille_associe).id_rang+comp+4)]
      #    #if feuille_reference!=[] and mtg.property('ParamFeuille').get(feuille_reference[0]).Phase=='visible':
      #    #  X.arretee=True
      # 
      #  #else: # Pointe d'une racine laterale
      #  #  if X.age > (ParamP[X.id_plante]['P_penteDureeVieDiamTMD']*X.diametre*ParamP[X.id_plante]['P_TMD']):
      #  #    X.arretee=True
      #  
      #  #if X.senile==False and TPS>10 and :
      #  #  X.senile=True    #La pointe devient senile
      #  
      #  #if X.senile==True:  #Teste si tout l'axe est mort
      #  #  base_axe=vertex_axe[0]
      #  #  les_pointes_axe=Extremities(base_axe)
      #  #  X.axe_mort=True
      #  #  for x in les_pointes_axe:
      #  #    if mtg.property('pte').get(x).senile==False:
      #  #      X.axe_mort=False
      #  
      #for i in TPS_expe:
      #  if TPS==i-2:
      #    nproduce GetPos(0,0,0)
      nproduce tip(X)
      produce
    
    else:
      for i in TPS_expe:
        if TPS==i-2:
          nproduce GetPos(0,0,0)
      produce tip(X)


Site(X):
  global mtg,num_pointe,les_pointes,groupe
  if OptionRacine=='SansRacines':
    produce *
  else:
    if groupe=='croissance':
      if X.diametre < ParamP[X.id_plante]['P_diamMin']:
        produce 
      elif X.age < ParamP[X.id_plante]['P_ageMaturitePointe']:
        X.age=X.age+dt
      else:
        num_pointe=num_pointe+1
        Y=pte(id_pointe=num_pointe,age=0,Tortue=X.Tortue,diametre=X.diametre,posO=X.posO)
        produce SB() tip(Y) EB()
    if groupe=='defoliation':
      produce Site(X)

#segment(X):
#  global les_pointes,Rootbiom
#  vertex_pointe=0
#  Rootbiom=Rootbiom+P_RootMasseVolumique*(pi*(X.diametre/2)*(X.diametre/2)*X.longueur)
#  
#  for x in les_pointes:
#    if mtg.property('pte').get(x).id_pointe==X.id_pointe_axe:
#      vertex_pointe=x
#      break
#  if mtg.property('pte').get(vertex_pointe).axe_mort:
#    nproduce
#  else:
#    nproduce segment(X)
#  produce


Feuille(X_Feuille, X_apex, X_phytomere) < FLW] \(orient) phytomere(Xphytomere1, X_AP1) [phytomere(Xphytomere2, X_AP2):
  # La feuille est ecartee par la talle axillante. Regle de contexte complewe qui permet de retrouver la talle axillante.
  X_Feuille.angletal = Xphytomere2.angletal


interpretation:


phytomere(X, Y):
  produce Right(X.angletal)


Entrenoeud(X, Y, Z, U):
  produce SetWidth(1)SetColor(3)F(X.length)


Feuille(X, Y, Z):
  global Surfoliaireencours,les_feuilles
  if groupe=='croissance':
    surfacefeuille=0
    Torsiongaine=ParamP[X.id_plante]['Torsiongaine']
    curve=ParamP[X.id_plante]['curve']*LSTEP
    Taillepointelineraire=ParamP[X.id_plante]['Taillepointelineraire']
    
    if (X.Phase=='cachee'):
      numsteps=(X.Taillefeuille-X.coupe)/LSTEP
      for i in range(int(numsteps)):
        taille=X.Taillefeuille
        L0=X.Taillefinalelimbe-taille
        
        if (i<((taille-Taillepointelineraire)/LSTEP)):
          large=(paramManagement['CoefSecondDegreLonLar']*pow(((L0+(i*LSTEP))/X.Taillefinalelimbe), 2)+paramManagement['CoefPremierDegreLonLar']*((L0+(i*LSTEP))/X.Taillefinalelimbe)+paramManagement['ConstantLonLar'])*(((paramManagement['CoefDirLonLarAjust']*log(X.Ymax))-paramManagement['OrdOriLonLarAjust'])/2)
        else:
          largini=(paramManagement['CoefSecondDegreLonLar']*pow(((L0+((i-1)*LSTEP))/X.Taillefinalelimbe), 2)+paramManagement['CoefPremierDegreLonLar']*((L0+((i-1)*LSTEP))/X.Taillefinalelimbe)+paramManagement['ConstantLonLar'])*(((paramManagement['CoefDirLonLarAjust']*log(X.Ymax))-paramManagement['OrdOriLonLarAjust'])/2)
          large=largini-((i-((taille-Taillepointelineraire)/LSTEP))*((largini*LSTEP)/Taillepointelineraire))
        
        if(i<(10/LSTEP)):
          rank=X.id_rang
          if large<=0:
            large=0.01
          nproduce  StartGC() SetContour(limbo) SetWidth(large)SetColor(2)Down(Torsiongaine*pow(-1,rank))F(LSTEP)EndGC()
        
        if(i>(10/LSTEP)):
          if large<=0:
            large=0.01
          nproduce StartGC() SetContour(limbo)SetWidth(large)SetColor(2)F(LSTEP)EndGC()
      produce
    
    if (X.Phase!='cachee'):
      #vtx_feuille=[x for x in les_feuilles if (mtg.property('ParamFeuille').get(x).id_plante==X.id_plante and mtg.property('ParamFeuille').get(x).id_talle==X.id_talle and mtg.property('ParamFeuille').get(x).id_rang==X.id_rang)][0]  # vertex de la feuille
      nproduce Left(X.angletal)
      
      if X.Cutstatus!='entierementcoupee':
        numsteps=ceil((X.Taillefeuille)/LSTEP)
      else:
        numsteps=ceil((X.Taillegaine)/LSTEP)
      numstepsg=ceil((X.Taillegaine)/LSTEP)
      
      for i in range(int(numsteps)):
        if (i<numstepsg-1):
          rank=X.id_rang
          large=max((2/pi)*(paramManagement['CoefDirLonLarAjust']*log(max(X.Taillegaine*5,1))-paramManagement['OrdOriLonLarAjust']),0.1)
          if(i<(10/LSTEP)):
            if(i==1):
              if large<=0:
                large=0.01
              nproduce SetWidth(large)SetContour(gaino)StartGC()SetColor(2)Down(Torsiongaine*pow(-1,rank))F(LSTEP)EndGC()
            else:
              if large<=0:
                large=0.01
              nproduce SetWidth(large)SetContour(gaino)StartGC()SetColor(2)Down(Torsiongaine*pow(-1,rank))F(LSTEP)EndGC() 
          
          else:
            if large<=0:
              large=0.01
            nproduce SetWidth(large)SetContour(gaino)StartGC()SetColor(2)F(LSTEP)EndGC()
        
        else:
          taille=X.Taillelimbe+X.coupe
          L0=X.Taillefinalelimbe-taille
          if ((i-numstepsg)<((taille-Taillepointelineraire)/LSTEP)):
            large=(paramManagement['CoefSecondDegreLonLar']*pow(((L0+((i-numstepsg)*LSTEP))/X.Taillefinalelimbe), 2)+paramManagement['CoefPremierDegreLonLar']*((L0+((i-numstepsg)*LSTEP))/X.Taillefinalelimbe)+paramManagement['ConstantLonLar'])*(((paramManagement['CoefDirLonLarAjust']*log(X.Ymax))-paramManagement['OrdOriLonLarAjust'])/2)
          else:
            a=pow(((L0+(((i-numstepsg)-1)*LSTEP))/X.Taillefinalelimbe), 2)
            b=log(X.Ymax)
            largini=(paramManagement['CoefSecondDegreLonLar']*pow(((L0+(((i-numstepsg)-1)*LSTEP))/X.Taillefinalelimbe), 2)+paramManagement['CoefPremierDegreLonLar']*((L0+(((i-numstepsg)-1)*LSTEP))/X.Taillefinalelimbe)+paramManagement['ConstantLonLar'])*(((paramManagement['CoefDirLonLarAjust']*log(X.Ymax))-paramManagement['OrdOriLonLarAjust'])/2)
            large=largini-(((i-numstepsg)-((taille-Taillepointelineraire)/LSTEP))*((largini*LSTEP)/Taillepointelineraire))
          
          if(i<numstepsg-1):
            large=0.
          
          surfacefeuille=surfacefeuille+large*2.*LSTEP
          #Surfoliaireencours=Surfoliaireencours+large*2.*LSTEP
          Agesenesc = paramManagement['T0sen'] + X.Ymax * 1.5
          
          if(i==numstepsg):
            if X.id_rang>4:
              pseudotige=max([Taille_finale_gaine[X.id_plante][X.id_talle][x] for x in range(X.id_rang-3,X.id_rang-1)])
            else:
              pseudotige=Taille_finale_gaine[X.id_plante][X.id_talle][X.id_rang-1]
            
            if ( X.Taillegaine > pseudotige):
              nproduce StartGC() SetContour(limbo)Left(X.angleinsert)SetColor(2)F(LSTEP)EndGC()
          
          if (X.age<=Agesenesc):
            if ((i>numsteps-2) and X.coupe>2): # Pour avoir cicatrice au bout feuille coupees
              if i<numstepsg:
                if X.Cutstatus=='entierementcoupee':
                  large_temp=max((2/pi)*(paramManagement['CoefDirLonLarAjust']*log(max(X.Taillegaine*5,1))-paramManagement['OrdOriLonLarAjust']),0.1)
                  if large_temp<=0:
                    large_temp=0.01
                  nproduce SetWidth(large_temp)SetContour(gaino)StartGC()SetColor(2)F(LSTEP)EndGC()
                else:
                  if large<=0:
                    large=0.01
                  nproduce StartGC() SetContour(limbo) SetWidth(large)RollR(0)Left(curve)SetColor(2)F(LSTEP)EndGC()
              
              else:
                if large<=0:
                  large=0.01
                nproduce StartGC() SetContour(limbo) SetWidth(large)RollR(0)Left(curve)SetColor(2)F(LSTEP)EndGC()
            
            if(X.id_rang==1 and X.id_talle>0):
              if (i>(X.TailleEmergence-2)/LSTEP):
                if large<=0:
                  large=0.01
                nproduce StartGC() SetContour(limbo) SetWidth(large)RollR(0)Left(curve)SetColor(2)F(LSTEP)EndGC()
              
              if (i<(X.TailleEmergence-2)/LSTEP): 
                rank=X.id_rang
                if(i<(10/LSTEP)):
                  if large<=0:
                    large=0.01
                  nproduce  StartGC() SetContour(foldlimbo) SetWidth(large)SetColor(2)Down(Torsiongaine*pow(-1,rank))F(LSTEP)EndGC()
                else:
                  if large<=0:
                    large=0.01
                  nproduce StartGC()SetContour(foldlimbo)SetWidth(large)SetColor(2)F(LSTEP)EndGC()
            
            else:
              if X.id_rang>4:
                pseudotige=max([Taille_finale_gaine[X.id_plante][X.id_talle][x] for x in range(X.id_rang-3,X.id_rang-1)])
              else:
                pseudotige=Taille_finale_gaine[X.id_plante][X.id_talle][X.id_rang-1]
              
              if ( i > pseudotige/LSTEP ):
                if i<numstepsg:
                  if X.Cutstatus=='entierementcoupee':
                    large_temp=max((2/pi)*(paramManagement['CoefDirLonLarAjust']*log(max(X.Taillegaine*5,1))-paramManagement['OrdOriLonLarAjust']),0.1)
                    if large_temp<=0:
                      large_temp=0.01
                    nproduce SetWidth(large_temp)SetContour(gaino)StartGC()SetColor(2)F(LSTEP)EndGC()
                  else:
                    if large<=0:
                      large=0.01
                    nproduce StartGC() SetContour(limbo) SetWidth(large)RollR(0)Left(curve)SetColor(2)F(LSTEP)EndGC()
                
                else:
                  if large<=0:
                    large=0.01
                  nproduce StartGC() SetContour(limbo) SetWidth(large)RollR(0)Left(curve)SetColor(2)F(LSTEP)EndGC()
              
              if (i<pseudotige/LSTEP):
                rank=X.id_rang
                if(i<(10/LSTEP)):
                  if large<=0:
                    large=0.01
                  nproduce  StartGC() SetContour(foldlimbo) SetWidth(large)SetColor(2)Down(Torsiongaine*pow(-1,rank))F(LSTEP)EndGC()
                else:
                  if large<=0:
                    large=0.01
                  nproduce StartGC()SetContour(foldlimbo)SetWidth(large)SetColor(2)F(LSTEP)EndGC()
          # Pour avoir feuille courbee et "s'ouvre" que quand en dehors de la gaine precedente la plus grande
          else:
            if X.age<=Agesenesc or not option_senescence:
              if large<=0:
                large=0.01
              nproduce StartGC() SetContour(limbo) SetWidth(large)Left(curve)SetColor(1)F(LSTEP)EndGC()
      produce


SegFeuille(X):
  produce SetColor(10)F(1)


apex(X):
  nproduce StartGC() SetColor(3) F(0.2) EndGC()


ApexTal(X):
  nproduce StartGC() SetColor(5) F(0.2) EndGC()


EntrenoeudEpi(X, Y):
  produce ;(5) F(X.long_entrenoeud)


Epillet(X, Y):
  produce ;(6) F(X.long_epillet)


tip(X):
  if X.longueur<=0:
    nproduce StartGC()   SetColor(1)PglShape(Cone(X.diametre/2+0.2,0.1,True,16)) EndGC()
  else:
    nproduce StartGC()   SetColor(1)PglShape(Cone(X.diametre/2+0.2,X.longueur,True,16)) EndGC()

segment(X):
  nproduce StartGC() SetWidth(X.diametre/2+0.2)SetColor(1)F(X.longueur)EndGC()

endlsystem
###### INITIALISATION ######

__lpy_code_version__ = 1.1

def __initialiseContext__(context):
	context.animation_timestep = 0.032
	context.options.setSelection('Module declaration',1)
	import openalea.plantgl.all as pgl
	profilelimbe = pgl.NurbsCurve2D(	
	    ctrlPointList = pgl.Point3Array([(-0.0864873, -1.28825, 1),(0.138172, -0.154037, 1),(0.134849, -0.160444, 1),(0.302985, -0.00246132, 1),(0.176901, 0.144132, 1),(0.149559, 0.150022, 1),(-0.0742404, 1.49117, 1)]) , 
	    )
	profilelimbe.name = "profilelimbe"
	profilefoldlimbe = pgl.NurbsCurve2D(	
	    ctrlPointList = pgl.Point3Array([(-0.202006, 0.250293, 1),(-0.262712, 0.243403, 1),(-0.285408, 0.179588, 1),(-0.166833, -0.0558834, 1),(0.238723, -0.168115, 1),(0.348058, 0.171371, 1),(0.33338, 0.337654, 1),(0.0711467, 0.435274, 1),(0.085187, 0.149124, 1),(0.0123227, 0.175151, 1)]) , 
	    )
	profilefoldlimbe.name = "profilefoldlimbe"
	profilegaine = pgl.NurbsCurve2D(	
	    ctrlPointList = pgl.Point3Array([(-0.407478, -0.0511938, 1),(-0.390245, -0.17963, 1),(-0.355, -0.3575, 1),(-0.0025, -0.4925, 1),(0.363333, -0.355, 1),(0.47, -5.58794e-09, 1),(0.349167, 0.3425, 1),(0.005, 0.455, 1),(-0.3275, 0.3625, 1),(-0.380592, 0.203264, 1),(-0.402904, 0.0550844, 1)]) ,
	    )
	profilegaine.name = "profilegaine"
	panel_0 = ({'name': 'Curve2D', 'active': True, 'visible': False},[('Curve2D',profilelimbe),('Curve2D',profilefoldlimbe),('Curve2D',profilegaine)])
	panel_1 = ({'name': 'Panel 2', 'active': True, 'visible': False},[])
	parameterset = [panel_0,panel_1,]
	context["__functions__"] = []
	context["__curves__"] = [('profilelimbe',profilelimbe),('profilefoldlimbe',profilefoldlimbe),('profilegaine',profilegaine),]
	context["__parameterset__"] = parameterset
	context["profilelimbe"] = profilelimbe
	context["profilefoldlimbe"] = profilefoldlimbe
	context["profilegaine"] = profilegaine
__references__ = '\n'
