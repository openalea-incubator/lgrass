from openalea.plantgl.all import * 
from openalea.mtg.io import *
from openalea.mtg.aml import *
from openalea.mtg.mtg import *
from alinea.caribu.CaribuScene import CaribuScene
from alinea.caribu.sky_tools import turtle
import random
from math import *
import numpy as np
import time as t
import csv
from copy import *
#import IOxls
import os
import pandas


##### Configuration du chemin #####
INPUTS_DIRPATH = 'inputs'
OUTPUTS_DIRPATH = 'outputs'

##### Parametres plante #####
path_param=os.path.join(INPUTS_DIRPATH,'Parametre_plante_Lgrass.xls') # Fichier contenant les parametres
onglet1='FL'
onglet2='FC'
#paramP1=IOxls.read_plant_param(path_param, onglet1) # Lecture du premier onglet
#paramP2=IOxls.read_plant_param(path_param, onglet2)
#paramManagement=IOxls.read_plant_param(path_param, 'Management')

TableParamP1=pandas.read_excel(path_param, sheetname=onglet1)
TableParamP2=pandas.read_excel(path_param, sheetname=onglet2)
paramP1=dict(zip(TableParamP1['name'],TableParamP1['value']))
paramP2=dict(zip(TableParamP2['name'],TableParamP2['value']))

TableManagement=pandas.read_excel(path_param,sheetname='Management')
paramManagement=dict(zip(TableManagement['name'],TableManagement['value']))

ParamP=[paramP2] #liste des parametres plante
nb_plantes=len(ParamP) 

num_pointe=0
num_primordium=0

LSTEP=1
DureeExp=2800

##### Parametre scene #####
OptionRacine='SansRacines' 
#OptionRacine='AvecRacines'

Densite=400 #en nb de plante par m2
Espacement=10*sqrt(10000/Densite) #en mm
#Espacement=200. # Distance entre chaque plante
NBlignes=int(ceil(sqrt(nb_plantes)))
NBcolonnes=int(floor(sqrt(nb_plantes)))
posPlante=[[i,j] for i,j in zip(sorted(range(NBlignes)*NBcolonnes),range(NBcolonnes)*NBlignes)]
genotype=[0]

##### Definition des contours pour la sortie graphique #####
limbo=profilelimbe.deepcopy()
foldlimbo=profilefoldlimbe.deepcopy()
gaino=profilegaine.deepcopy()

##### Parametres coupe #####
groupe='croissance' # Permet de realiser les coupes
reprise_coupe=False
#CoupeTaille=600000.

##### Sorties #####
outvarfile='surface_biomass_%s_%s_%s.csv'%(int(Espacement),DureeExp,ParamP[0]['HCOUP'])
outvarfile2='sortie_simul_ValidCoupe_%s_%s_%s.csv'%(int(Espacement),DureeExp,ParamP[0]['HCOUP'])
outvarfile3='sorties_feuilles_finales_%s_%s_%s.csv'%(int(Espacement),DureeExp,ParamP[0]['HCOUP'])
#output_apex = 'output_apex_%s_%s_%s.csv'%(int(Espacement),DureeExp,ParamP[0]['HCOUP'])                  # Ajout SIMON
output_organ_characteristics = 'output_organ_characteristics%s_%s_%s.csv'%(int(Espacement),DureeExp,ParamP[0]['HCOUP'])    
outimage='Scene\scene_'+str(int(Espacement))+'_'+t.strftime('%d-%m-%y_%Hh%M',t.localtime())+'.bmp'

output_apex_characteristics = 'output_apex_characteristics%s_%s_%s.csv'%(int(Espacement),DureeExp,ParamP[0]['HCOUP'])
output_internode_characteristics = 'output_internode_characteristics%s_%s_%s.csv'%(int(Espacement),DureeExp,ParamP[0]['HCOUP'])

##### Maitrise de l'aleatoire #####
seed=0
random.seed(seed)
alea1=[random.random() for x in xrange(4000)]
alea2=[random.random() for x in xrange(4000)]

##### Activation du tallage
option_tallage = False

##### Activation de la senescence
option_senescence = False


##### Activation de la floraison ##### AJOUT SIMON
option_floraison = True        # True or False

# Output for batch
output_batch_dict = {}
flowering_model = None

if flowering_model == None:
  from lgrass import flowering_functions
  flowering_model = flowering_functions.FloweringFunctions()

#########   Definition Plante   #########
scales={}
parameters={}

scales['CouvertVegetal']=1
parameters['CouvertVegetal']=[]

class ParamPlante:
  def __init__(self,id_plante=0,id_geno=0):
    self.id_plante=id_plante
    self.id_geno=id_geno
    self.TEMPORAIRE=0
    self.surfolPlante=[0 for i in xrange((NBlignes)*(NBcolonnes))]
  
  ### Fonctions utilisees pour le calcul du LAI local ###
  def posTOnum(self, pos): #Determination de l'id de la plante a partir de la position
    ret=-1
    for i in xrange((NBlignes)*(NBcolonnes)):
      if (posPlante[i]==pos):
        ret=i
    return ret
  
  def numTOpos(self, id_plante): #Determination de la position de la plante a partir de l'id
    return posPlante[id_plante]
  
  def deplacPos(self, pos, depl): #Selectionne la plante adjacente donnee
    ret=list(pos)  #Cree une copie de pos
    if ((depl[0]==-1 or depl[0]==0 or depl[0]==1) and (depl[1]==-1 or depl[1]==0 or depl[1]==1)): #Valeurs entre -1 et 1 : plantes adjacentes et non a 2 espacements
      ret[0]=pos[0] + depl[0]
      ret[1]=pos[1] + depl[1]
      #Simulation d'un couvert de taille infini:
      if (ret[0] == -1): ret[0] = NBlignes-1
      if (ret[0] == NBlignes): ret[0] = 0
      if (ret[1] == -1): ret[1] = NBcolonnes-1
      if (ret[1] == NBcolonnes): ret[1] = 0
    return ret
  
  def adj9Plantes(self, pos): #Fait la liste des plantes adjacentes
    ret=[[0,0] for i in xrange(8)]
    ret[0]=self.deplacPos(pos, [-1,-1])
    ret[1]=self.deplacPos(pos, [ 0,-1])
    ret[2]=self.deplacPos(pos, [ 1,-1])
    ret[3]=self.deplacPos(pos, [ 1, 0])
    ret[4]=self.deplacPos(pos, [ 1, 1])
    ret[5]=self.deplacPos(pos, [ 0, 1])
    ret[6]=self.deplacPos(pos, [-1, 1])
    ret[7]=self.deplacPos(pos, [-1, 0])
    return ret
  
  def surfol9Plantes(self, id_plante): #Calcule la surface foliaires des 8 plantes adjacentes
    adj=self.adj9Plantes(self.numTOpos(id_plante)) #liste des positions des plantes adjacentes
    ret=0    
    for p in adj:
      if self.posTOnum(p)>-1:
        ret+=Surfoliairetotale[self.posTOnum(p)]
    return ret
  
  def rapportS9_SSol(self, id_plante): #Utilise pour simuler l'impact des voisins
    ret=self.surfol9Plantes(id_plante)/(Espacement**2*9) #Rapport surface foliaires des 9 plantes/surface au sol occupee par les 9 plantes
    if (self.TEMPORAIRE <> self.surfol9Plantes(id_plante)):
      self.TEMPORAIRE=self.surfol9Plantes(id_plante)
    return ret
FonctionParamPlante=ParamPlante()
scales['Plante']=2
parameters['Plante']=['ParamPlante']

class ParamPhytomere:
  def __init__(self, id_plante=0, id_talle=0, id_rang=0,age=0,  angletal=0):#, Carbdescend=0, Carbmonte=0):
    self.id_plante=id_plante
    self.id_talle=id_talle
    self.id_rang=id_rang
    self.age=age
    self.angletal=angletal
#    self.Carbdescend=Carbdescend
#    self.Carbmonte=Carbmonte
scales['phytomere']=3
parameters['phytomere']=['ParamPhytomere']

scales['Entrenoeud']=4
parameters['Entrenoeud']=[]

class ParamFeuille:
  def __init__(self,age=0, Agecroiss=0, Taillefeuille=0, id_plante=0, id_talle=0, id_rang=1, Ymax= 0, Difftps=0,  Taillefinalelimbe=0, Taillefinalegaine=0., Taillelimbe=0, Taillegaine=0, Phase='cachee', rapportK=0.2, coupe=0.,Cutstatus='intact', angleinsert=0,angletal=0., geno=0, surface=0, biomass=0., Besoinencroiss=0,TailleEmergence=0.,R=0.973):
    self.age=age                             # Age de la feuille
    self.Agecroiss=Agecroiss                 # 
    self.Taillefeuille=Taillefeuille         # Taille de la feuille au temps t
    self.id_plante=id_plante                 # Identifiant de la plante (compris entre 0 et nb_plantes)
    self.id_talle=id_talle                   # Identifiant de la talle
    self.id_rang=id_rang                     # Rang de la feuille
    self.Ymax=Ymax                           # Taille finale de la feuille
    self.Difftps=Difftps                     # Delai entre l'apparition de 2 feuilles
    self.Taillefinalelimbe=Taillefinalelimbe # Taille finale du limbe
    self.Taillefinalegaine=Taillefinalegaine # Taille finale de la gaine
    self.Taillelimbe=Taillelimbe             # Taille du limbe au temps t
    self.Taillegaine=Taillegaine             # Taille de la gaine au temps t
    self.Phase=Phase                         # Stade de la feuille : cachee, visible, 0 0
    self.rapportK=rapportK                   # Rapport gaine/limbe
    self.coupe=coupe                         # Longueur de coupe
    self.Cutstatus=Cutstatus                 # Quantite de coupe : intact, partiellementcoupee(=feuille coupee et gaine intacte), entierementcoupee(=feuille et gaine coupee)
    self.angleinsert=angleinsert             # Angle limbe
    self.angletal=angletal                   # Angle de la talle qui ecarte la feuille
    self.geno=geno
    self.surface=surface                     # Surface foliaire
    self.biomass=biomass
    self.Besoinencroiss=Besoinencroiss
    self.TailleEmergence=TailleEmergence
    self.R=R
scales['Feuille']=4
parameters['Feuille']=['ParamFeuille']

class ParamSegFeuille:
  def __init__(self,id_plante,idLong,hauteur):
    self.id_plante=id_plante
    self.idLong=idLong
    self.hauteur=hauteur
scales['SegFeuille']=5
parameters['SegFeuille']=['ParamSegFeuille']

class ParamEntrenoeud:
  def __init__(self, id_plante, id_talle, id_rang = 1, internode_type = 'short_internode', length = 0, width = 2, final_length = 10):
    self.id_plante = id_plante                    # Id of the plant (between 0 and number of plants-1) 
    self.id_talle = id_talle                      # Id of the tiller
    self.id_rang = id_rang                        # Rank of the phytomere
    self.internode_type = internode_type          # Type of the internode mean : short_internode or long_internode
    self.length = length                          # Current length of the internode when time = t
    self.width = width                            # Width of the internode, constant
    self.final_length = final_length              # Final length of the internode (function of the sheath of the previous phytomere)
scales['Entrenoeud']=4
parameters['Entrenoeud']=['ParamEntrenoeud']

class ParamApex:
  def __init__(self, id_plante, id_talle, id_rang = 1,retard = 0, total_emerged_leaf = 0, total_created_leaves = 0, day = 0, primary_induction_index = 0, phenological_state = 'vegetative', primordia_number = 3, spikelet_primordia_number=6, potential_leaf_number = np.nan, approx_final_leaf_number = np.nan, final_leaf_number = 0, nb_epillets=10):   # PARAMETRE
    self.id_plante = id_plante
    self.id_talle = id_talle
    self.id_rang = id_rang
    self.retard = retard
    self.total_emerged_leaf = total_emerged_leaf
    self.total_created_leaves = total_created_leaves                         # number of leaves produced by the apex
    self.day = day
    self.primary_induction_index = primary_induction_index
    self.phenological_state = phenological_state        # Phenological state of the apex. Values : vegetative, reproductive, dead
    self.primordia_number = primordia_number
    self.spikelet_primordia_number = spikelet_primordia_number
    self.potential_leaf_number = potential_leaf_number
    self.approx_final_leaf_number = approx_final_leaf_number
    self.final_leaf_number = final_leaf_number
    self.nb_epillets = nb_epillets
scales['apex']=4
parameters['apex']=['ParamApex']

class ParamApexTal:
  def __init__(self,id_plante,id_talle=0,id_rang=1,retard=0, day = 0, primary_induction_index = 0, secondary_induction_index = 0, phenological_state = 'vegetative'):
    self.id_plante=id_plante
    self.id_talle=id_talle
    self.id_rang=id_rang
    self.retard=retard
    self.day = day
    self.primary_induction_index = primary_induction_index
    self.secondary_induction_index = secondary_induction_index
    self.phenological_state = phenological_state        # Phenological state of the apex. Values : vegetative, reproductive, dead
scales['ApexTal']=4
parameters['ApexTal']=['ParamApexTal']


class ParamEpi:
  def __init__(self, id_plante, id_talle, id_rang, nb_epillets):
    self.id_plante = id_plante
    self.id_talle = id_talle
    self.id_rang = id_rang
    self.nb_epillets = nb_epillets              # Nombre d epillets a l apex
scales['Epi']=4
parameters['Epi']=['ParamEpi']

class ParamEntrenoeudEpi:
  def __init__(self, id_plante, id_talle, id_rang, long_entrenoeud=0):
    self.id_plante=id_plante
    self.id_talle=id_talle
    self.id_rang=id_rang
    self.long_entrenoeud = long_entrenoeud      # Longueur moyenne des entrenoeuds (entre chaque insertion d epillet)
scales['EntrenoeudEpi']=5
parameters['EntrenoeudEpi']=['ParamEntrenoeudEpi']

class ParamEpillet:
  def __init__(self, id_plante, id_talle, id_rang, long_epillet=0):
    self.id_plante=id_plante
    self.id_talle=id_talle
    self.id_rang=id_rang
    self.long_epillet = long_epillet            # Longueur moyenne des epillets
scales['Epillet']=5
parameters['Epillet']=['ParamEpillet']


class ParambourgeonRoot:
  def __init__(self,id_plante,id_talle=0,id_rang=1,nb_prod_root=0):
    self.id_plante=id_plante
    self.id_talle=id_talle
    self.id_rang=id_rang
    self.nb_prod_root=nb_prod_root
scales['bourgeonRoot']=4
parameters['bourgeonRoot']=['ParambourgeonRoot']

class ParamRacine:
  def __init__(self,age=0, id_plante=0 ,id_talle=0 ,id_rang=0,axe_arret=0,lateral_arret=0,feuil_ref=0):
    self.age=age
    self.id_plante=id_plante
    self.id_talle=id_talle
    self.id_rang=id_rang
    self.axe_arret=axe_arret
    self.lateral_arret=lateral_arret
    self.feuil_ref=feuil_ref
scales['racine']=4
parameters['racine']=['ParamRacine']

class pte:
  def __init__(self, id_pointe=0,id_plante=0, age=0, diametre=0., distPrimInit=0., longueur=0.01, profondeur=0.,dateDerniereCreation=0, posO=np.array([0.,0.,0.]),Tortue=np.array([[0.,0.,-1.],[0.,1.,0],[-1.,0.,0.]]), isaxe=False,arretee=False, senile=False,axe_mort=False,segment=0):
    self.id_pointe=id_pointe
    self.id_plante=id_plante
    self.age=age
    self.diametre=diametre
    self.distPrimInit=distPrimInit
    self.longueur=longueur
    self.profondeur=profondeur
    self.dateDerniereCreation=dateDerniereCreation
    self.posO=posO                                  # Position de la pointe dans l'espace
    self.Tortue=Tortue
    self.isaxe=isaxe
    self.arretee=arretee                            # 
    self.senile=senile                              # Etat de senescence de la pointe
    self.axe_mort=axe_mort
    self.segment=segment
scales['tip']=5
parameters['tip']=['pte']

class primord:
  def __init__(self, id_plante,id_primord,age,diametre,Tortue=np.array([[0.,0.,-1],[0.,1,0],[-1.,0.,0.]]),avorte=False,id_pointe_axe=0,posO=np.array([0.,0.,0.])):
    self.id_plante=id_plante
    self.id_primord=id_primord
    self.age=age
    self.diametre=diametre
    self.Tortue=Tortue
    self.avorte=avorte
    self.id_pointe_axe=id_pointe_axe
    self.posO=posO
scales['Site']=5
parameters['Site']=['primord']

class seg:
  def __init__(self, jourForm,diametre,longueur=0.,id_pointe_axe=0):
    self.jourForm=jourForm
    self.diametre=diametre
    self.longueur=longueur
    self.id_pointe_axe=id_pointe_axe
scales['segment']=5
parameters['segment']=['seg']

#########   definition sol   #########
path_sol=os.path.join(INPUTS_DIRPATH,'sol2.txt')
fichier_sol=open(path_sol,"rb")
tableau_sol=csv.reader(fichier_sol,delimiter='	')
Sol=[]
j=0
for x in tableau_sol:
  if j==0:
    j=1
  else:
    Sol.append(x)
fichier_sol.close()

class Horizon:# Horizon de sol
  def __init__(self,croiss,ramif,iCMeca,oCMeca):
    self.croiss  # Coefficient de croissance, compris entre 0 et 1
    self.ramif   # Coefficient multiplicateur de distance inter-ramif
    self.iCMeca  # Intensite de la contrainte mecanique
    self.oCMeca  # Orientation de la contrainte mecanique (O iso, ou 1 vert)




module CouvertVegetal : scale=1
module Plante(ParamPlante) : scale=2
module phytomere(ParamPhytomere, ParamApex) : scale=3
module Entrenoeud(ParamEntrenoeud, ParamApex, ParamFeuille) : scale=4
module Feuille(ParamFeuille, ParamApex) : scale=4
module SegFeuille(ParamSegFeuille) : scale=5
module apex(ParamApex) : scale=4
module ApexTal(ParamApexTal) : scale=4
module Epi(ParamEpi) : scale=4
module EntrenoeudEpi(ParamEntrenoeudEpi) : scale = 5
module Epillet(ParamEpillet) : scale = 5
module bourgeonRoot(ParambourgeonRoot, ParamEntrenoeud) : scale=4
module racine(ParamRacine) : scale=4
module segment(seg) : scale=5
module tip(pte) : scale=5
module Site(primord) : scale=5
module IN
module FLW

#sous_mtg=[False,False,False,True,False] # Indique quels sont les echelle sous-mtg de l'echelle precedente
TREE=[False,False,True,False,True]

### Calcul du rayonnement direct via Caribu ###
def apply_caribu(lstring, lscene, ligthsources):
  Pattern=(-Espacement/2, -Espacement/2, Espacement*(NBlignes-1)+Espacement/2, Espacement*(NBcolonnes-1)+Espacement/2)
  c_scene=CaribuScene(scene=lscene, light=ligthsources, pattern=Pattern, opt=None)
  if Pattern!=None:
    output=c_scene.run(direct=True,infinite=True)
  else:
    output=c_scene.run(direct=True,infinite=False)  
  c_res=output[1]['default_band']['Eabs']   
  return c_res

### Creation du MTG ###
def my_axialtree2mtg(tree, scale, scene, parameters, TREE=[]):
  def scene_id(scene):
    d={}
    if scene:
      for sh in scene:
        d.setdefault(sh.id,[]).append(sh)
      return d
  
  def change_id(axial_id, mtg_id):
    if geoms:
      if geoms.has_key(axial_id):
        for shape in geoms[axial_id]:
          shape.id=mtg_id
          mtg.property('geometry')[mtg_id]=geoms[axial_id]
      else:
        pass
  
  nombre=0 
  nombre2=0
  symbols=['IN','FLW','[',']']
  
  geoms=scene_id(scene)
  mtg=MTG()
  if scene:
    mtg.add_property('geometry')
  
  if parameters is None:
    parameters={}
  for label in parameters:
    for p in parameters[label]:
      if p not in mtg.property_names():
        mtg.add_property(p)
  
  vid=mtg.root
  current_vertex=vid
  branching_stack=[vid]
  pending_edge='' # edge type for the next edge to be created
  
  indoor=0
  follow=0  
  
  for aid, modul in enumerate(tree):
    label=modul.name
    
    if (label not in scale)and(label not in symbols):
      continue
    elif label =='IN':
      indoor=1
    
    elif label=='FLW':
      follow=1
    
    elif label == '[':
      if indoor==0 and follow==0:        
        branching_stack.append(current_vertex)
        pending_edge='+'
      elif indoor==1:
        indoor=0
      else:
        follow==0
    
    elif label == ']':
      if indoor==0 and follow==0 and branching_stack!=[0]:
        current_vertex=branching_stack.pop()
        pending_edge=''
      elif indoor==1:
        indoor=0
      else:
        follow=0
    
    else:
      nombre=nombre+1
      _scale=scale[label]
      _params=parameters.get(label, [])
      
      params={}
      params['label']=label
      for p in _params:
        if modul.hasParameter(p):
          params[p]=modul.getParameter(p)      
      
      if _scale==mtg.scale(current_vertex)+1:
        current_vertex=mtg.add_component(current_vertex, **params)
        if _scale==5:
          indoor=0
          follow=0
        nombre2=nombre2+1
      elif mtg.scale(current_vertex) == _scale: # Add a vertex at the finer scale
        if pending_edge == '+':
          edge_type='+'
        else:
          edge_type='<'
        params['edge_type']=edge_type
        current_vertex=mtg.add_child(current_vertex, **params)
        pending_edge=''
        nombre2=nombre2+1
      elif mtg.scale(current_vertex) > _scale:
        if TREE[_scale-1]==False:
          params['edge_type']=''
        else:
          if pending_edge=='+':
            edge_type='+'
          else:
            edge_type='<'
          params['edge_type']=edge_type
          
        while mtg.scale(current_vertex) > _scale:
          current_vertex=mtg.complex(current_vertex)
        
        current_vertex=mtg.add_child(current_vertex, **params)
        vid=current_vertex
        pending_edge=''
        nombre2=nombre2+1
      
      if label=='Feuille' or _scale==len(TREE)-1:
        change_id(aid,current_vertex)
  
  mtg=fat_mtg(mtg)
  return mtg

def LongueurFeuilleCoupee(vtx_feuille,ID): #Renvoie idLong si hauteur>HCOUP, renvoie -1 si hauteur<HCOUP
  global mtg
  for x in Components(vtx_feuille):
    if mtg.property('ParamSegFeuille').get(x).hauteur>ParamP[ID]['HCOUP']:
      return mtg.property('ParamSegFeuille').get(x).idLong
  return -1 

########   Fonction racinaires   ########
def Gravitropisme(ID,vertex,segment,profondeur,elong,init):#age,ordre,Turtle):
  global mtg
  Tortue=mtg.property('pte').get(vertex).Tortue
  if (Order(vertex)==0 and segment==0 and init==1):# idem a (age==0 and ordre==0) signifie 1ere croissance de la racine
    alpha=pi
    while alpha> (pi/2):
      alpha=random.normalvariate(ParamP[ID]['P_angInitMoyVertPrim'],ParamP[ID]['P_angInitETVertPrim'])
    beta=random.random()*2*pi 
  
  elif (segment==0 and init==1):# idem a age=0 signifie 1ere croissance d'une laterale
    alpha=ParamP[ID]['P_angLat']
    beta=random.random()*2*pi
  
  else:
    tortue=np.array([Tortue[:,0]])/np.linalg.norm(Tortue[:,0]) # vect direction pointe
    G=np.array([0,0,-ParamP[ID]['P_intensiteTropisme']*elong*mtg.property('pte').get(vertex).diametre]) # vect gravitropisme
    
    ### vect meca ###
    cont=float(Sol[Couche(ID,profondeur)][2])
    #Dx=random.random()*2-1
    #sign=(floor(random.random()*2))*2-1
    #Dy=sign*sin(acos(Dx))
    #Meca=0.5*(Dx*np.array([Tortue[:,1]]/np.linalg.norm(Tortue[:,1]))+Dy*np.array([Tortue[:,2]]/np.linalg.norm(Tortue[:,2])))
    
    if Sol[Couche(ID,profondeur)][3]==1:#(oCMecaSol(sol,profondeur)==1)  # Contrainte anisotrope verticale
      # On est dans le cas ou le sol est compose de nombreux tunnel verticaux de vers de terre qui entraine une orientation assez verticale des racines
      teta=15*pi/180
      ang_insertion=random.random()*2*teta-teta
      ang_radial=random.random()*2*pi
      RotLeft=np.array([[1,0,0],[0,cos(ang_radial),-sin(ang_radial)],[0,sin(ang_radial),cos(ang_radial)]])
      RotUp=np.array([[cos(ang_insertion),sin(ang_insertion),0],[-sin(ang_insertion),cos(ang_insertion),0],[0,0,1]])  
      Rot=np.dot(Tortue,RotLeft)
      Meca=np.dot(Rot,RotUp)/np.linalg.norm(Meca[:,0])*elong *cont
    
    else:
      ang_insertion=random.random()*pi-pi/2
      ang_radial=random.random()*2*pi
      RotLeft=np.array([[1,0,0],[0,cos(ang_radial),-sin(ang_radial)],[0,sin(ang_radial),cos(ang_radial)]])
      RotUp=np.array([[cos(ang_insertion),sin(ang_insertion),0],[-sin(ang_insertion),cos(ang_insertion),0],[0,0,1]])
      Rot=np.dot(Tortue,RotLeft)
      Meca=np.dot(Rot,RotUp)
      Meca=Meca[:,0]/np.linalg.norm(Meca[:,0])
      Meca=Meca*elong*cont
    
    ### vect final ###
    newtortue=tortue+G+Meca
    newtortue=newtortue/np.linalg.norm(newtortue)
    A=np.array([0.,0.,0.])
    for i in xrange(3):
      a=np.array([Tortue[0,:],Tortue[1,:],Tortue[2,:]])
      a[:,i]=newtortue
      A[i]=np.linalg.det(a)/float(np.linalg.det(Tortue))
    
    A=A/np.linalg.norm(A)
    alpha=acos(A[0])
    beta=acos(-A[1]/sin(alpha))
    
    if ((A[2] <0 and -sin(alpha)*sin(beta)>0) or (A[2] >0 and -sin(alpha)*sin(beta)<0)) :
      beta=-beta    
  
  RotLeft=np.array([[1,0,0],[0,cos(beta),-sin(beta)],[0,sin(beta),cos(beta)]])
  RotUp=np.array([[cos(alpha),sin(alpha),0],[-sin(alpha),cos(alpha),0],[0,0,1]])
  Rot=np.dot(Tortue,RotLeft)
  newTurtle=np.dot(Rot,RotUp)
  #newTurtle[:,0]=newTurtle[:,0]/np.linalg.norm(newTurtle[:,0])
  
  pos=mtg.property('pte').get(vertex).posO
  newpos=pos+newTurtle[:,0]*elong
  return (newTurtle,newpos)

#def CroissanceRacine(X,profondeur):
#  ID=X.id_plante
#  return (X.diametre - ParamP[ID]['P_diamMin'])* dt * ParamP[ID]['P_penteVitDiam'] * float(Sol[Couche(ID,profondeur)][0])
#  #return ParamP[ID]['P_elongMax']*(1+(max(0,(ParamP[ID]['P_diamMax']-X.diametre))/(ParamP[ID]['P_diamMax']-ParamP[ID]['P_diamVM'])))*pow((min(1,(X.diametre-ParamP[ID]['P_diamMin'])/(ParamP[ID]['P_diamMax']-ParamP[ID]['P_diamMin']))),((ParamP[ID]['P_diamMax']-ParamP[ID]['P_diamMin'])/(ParamP[ID]['P_diamMax']-ParamP[ID]['P_diamVM'])))

def CroissanceRacine2(X,profondeur):
  ID=X.id_plante
  if X.diametre>ParamP[ID]['P_diamMax']:
    return ParamP[ID]['P_elongMax']
  else:
    return ParamP[ID]['P_elongMax']*(1+(max(0,(ParamP[ID]['P_diamMax']-X.diametre))/(ParamP[ID]['P_diamMax']-ParamP[ID]['P_diamVM'])))*pow((min(1,(X.diametre-ParamP[ID]['P_diamMin'])/(ParamP[ID]['P_diamMax']-ParamP[ID]['P_diamMin']))),((ParamP[ID]['P_diamMax']-ParamP[ID]['P_diamMin'])/(ParamP[ID]['P_diamMax']-ParamP[ID]['P_diamVM'])))

def tireDiamPointeFille(ID,diametre_pere): # Tire le diametre d'un meristeme de ramification suivant celui du pere pour la ramification sequentielle
  moy=diametre_pere*ParamP[ID]['P_propDiamRamif'] #+ (ParamP[ID]['P_diamMin']*(1.0-ParamP[ID]['P_propDiamRamif']))
  et=moy*ParamP[ID]['P_coeffVarDiamRamif']
  diamPFille=10.0 # Initialisation a une forte valeur
  while (diamPFille>(1.1*diametre_pere)):
     diamPFille=random.normalvariate(moy,et)
  return diamPFille

#def Distance(v1,v2):  
#  dist=0
#  chemin=Path(v1,v2)
#  chemin.append(v1)
#  for x in chemin:
#    if Class(x)=='s':
#      geo=g.property('geometry').get(x)[0]
#      points=geo.geometry.axis.pointList
#      long=sqrt((points[0][0]-points[1][0])**2+(points[0][1]-points[1][1])**2+(points[0][2]-points[1][2])**2)
#      dist=dist+long
#  return dist

def Couche(ID,profondeur):
  hor=-floor(profondeur/ParamP[ID]['epaisseurHorizon'])
  if hor>=ParamP[ID]['NBHORIZONMAX']:
    hor=ParamP[ID]['NBHORIZONMAX']-1
  if hor<0:
    hor=0  
  return int(hor)

def DetermineAccroiss(Pourcentage,X,AccroissDemande):
  newbiomass=X.biomass+X.Besoinencroiss*Pourcentage
  if newbiomass>X.biomass:
    newtaille=X.Taillefeuille
    while BiomassFeuille(newtaille,X.coupe,X.geno)<newbiomass and newtaille<(X.Taillefeuille+AccroissDemande):
      newtaille+=0.1
    newtaille=newtaille-0.1
    while BiomassFeuille(newtaille,X.coupe,X.geno)<newbiomass and newtaille<(X.Taillefeuille+AccroissDemande):
      newtaille+=0.01
    return newtaille-0.005-X.Taillefeuille
  else:
    return 0

def BiomassFeuille(long,coupe,geno):
  coupe=0
  if geno<2:
    if long==0:
      MS=0
    else:
      MS=paramManagement['FacBiom1']*(paramManagement['b0']*exp(paramManagement['b1']*(long+coupe)**2+paramManagement['b2']*(long+coupe))-paramManagement['b0'])*(long/(long+coupe))
  else:
    if long==0:
      MS=0
    else:
      MS=paramManagement['FacBiom2']*(paramManagement['b0']*exp(paramManagement['b1']*(long+coupe)**2+paramManagement['b2']*(long+coupe))-paramManagement['b0'])*(long/(long+coupe))
  return MS







def Start():
  global alea1_index,timing,growth_realized,dt,TPS,TPS_expe #Parametres de temps
  global surface_biomass,chemin_fichier1,chemin_fichier2,chemin_fichier3,long_root,simul_expe,taille_finale_feuille #Fichiers de sortie
  global Biomasse_aerienne,Biomasse_racinaire,BiomProd,Ray,PourcentageRootGrowthRealized,PourcentageRootGrowthRealized,Reserve,Demande_feuille,Demande_feuille_dans_gaine,Demande_feuille_hors_gaine,PourcentageFeuilGrowthRealized,les_diametres,Seuil,Taille_finale_gaine,nb_talle #Parametres vides
  global NBlignes,NBcolonnes,posPlante,Espacement #Parametres scene
  global Surfoliairetotale,Surfoliaireencours,Premiecroiss #Definition des groupes de production
  global Alpha,Beta,t1,t2,t3,Caribu #Relation allometrique
  global current_day, meteo, apex_characteristics, internode_characteristics # AJOUT SIMON
  
  alea1_index=[0]*nb_plantes
  
  ##### Parametres de temps #####
  timing=t.time()
  growth_realized=1
  dt=1
  TPS=0.
  TPS_expe=range(1000)
  
  ###### AJOUT SIMON METEO ########
  # Importation de la meteo et adaptation a l incrementation en temps thermique
  meteo_path = os.path.join(INPUTS_DIRPATH,'meteo_file.csv')
  meteo = pandas.read_csv(meteo_path, sep=';')
  meteo['thermal_time_cumul'] = meteo.mean_temperature.cumsum()
  current_day = min(meteo.id_day)
  
  ##### Creation de parametres vides #####
  Biomasse_aerienne=[0.]*(nb_plantes) # Biomasse foliaire
  Biomasse_racinaire=[0.]*(nb_plantes) # Biomasse racinaire
  BiomProd=[0.]*(nb_plantes)
  Ray=[0.]*(nb_plantes)
  PourcentageRootGrowthRealized=[0]*(nb_plantes)
  Reserve=[0]*(nb_plantes) # Reserve de "biomass"
  Demande_feuille=[0]*(nb_plantes)
  Demande_feuille_dans_gaine=[0]*(nb_plantes)
  Demande_feuille_hors_gaine=[0]*(nb_plantes)
  #Next_biom_feuil=[0]*(nb_plantes)
  PourcentageFeuilGrowthRealized=[1]*(nb_plantes)
  les_diametres=[]
  Seuil=[] # Taille a partir de laquelle la plante est consideree comme hors de la gaine
  Taille_finale_gaine=[]
  nb_talle=[]  # nombre_de_talle-1 pour chaque plante afin d'identifier les talles
  
  ##### Parametres scene #####
  NBlignes=int(ceil(sqrt(nb_plantes)))
  NBcolonnes=int(floor(sqrt(nb_plantes)))
  posPlante=[[i,j] for i,j in zip(sorted(range(NBlignes)*NBcolonnes),range(NBcolonnes)*NBlignes)]
  Espacement=10*sqrt(10000/Densite) #en mm
  
  ##### Definition des groupes de production #####
  Surfoliairetotale =[0.]*(nb_plantes) # Surface folaire totale obtenue a la fin d'un pas
  Surfoliaireencours=[0.]*(nb_plantes) # variable de calcul de la surface foliaire totale
  Premiecroiss=[ParamP[i]['Premiecroiss'] for i in xrange(nb_plantes)]
  
  ##### Relation allometrique #####
  Alpha=[ParamP[i]['Alpha'] for i in xrange(nb_plantes)]
  Beta=[ParamP[i]['Beta'] for i in xrange(nb_plantes)]
  t1=[ParamP[i]['t1'] for i in xrange(nb_plantes)]
  t2=[ParamP[i]['t2'] for i in xrange(nb_plantes)]
  #t3=[ParamP[i]['t3'] for i in xrange(nb_plantes)]
  Caribu="Off"
  
  ##### Ecriture des fichiers de sortie #####
  chemin_fichier1=open(os.path.join(OUTPUTS_DIRPATH,outvarfile),"wb")
  surface_biomass=csv.writer(chemin_fichier1)
  surface_biomass.writerow(["TPS","Espacement","Densite","id plante","X.coupe","id talle","ordre","nb_feuillemergees","MS_feuille","Surface foliaire"])
  
  chemin_fichier2=open(os.path.join(OUTPUTS_DIRPATH,outvarfile2),"wb")
  simul_expe=csv.writer(chemin_fichier2)
  simul_expe.writerow(["TPS","Espacement","Densite","C","id_plante","nb_feuille","nb_talle_emergees","nb_feuilles_talle1","nb_feuilles_talle2","nb_feuilles_talle3"])
  
  chemin_fichier3=open(os.path.join(OUTPUTS_DIRPATH,outvarfile3),"wb")
  taille_finale_feuille=csv.writer(chemin_fichier3)
  taille_finale_feuille.writerow(["TPS","Espacement","Densite","id plante","talle","rang","Phase","taille feuille","taille gaine","taille limbe"])
  
  
  # AJOUT SIMON
  apex_characteristics_path = open(os.path.join(OUTPUTS_DIRPATH, output_apex_characteristics), "wb")
  apex_characteristics = csv.writer(apex_characteristics_path)
  apex_characteristics.writerow(['day', 'thermal_time', 'plant_id', 'tiller_id', 'rank', 'total_emerged_leaf', 'total_created_leaves', 'primary_induction_index', 'phenological_state', 'primordia_number', 'potential_leaf_number', 'approx_final_leaf_number', 'final_leaf_number'])
  
  internode_characteristics_path = open(os.path.join(OUTPUTS_DIRPATH, output_internode_characteristics), "wb")
  internode_characteristics = csv.writer(internode_characteristics_path)
  internode_characteristics.writerow(['day', 'thermal_time', 'plant_id', 'tiller_id', 'rank', 'internode_type', 'internode_length'])



def StartEach():
  global RootPotentialNewBiomass,longueur_totale_feuille,Rootbiom,groupe,dt,reprise_coupe,CoupeTaille
  global current_day, meteo, apex_characteristics, internode_characteristics
  
  RootPotentialNewBiomass=[0]*(nb_plantes)
  longueur_totale_feuille=0
  Rootbiom=0
  
  for ID in xrange(nb_plantes):
    ### Declenchement de la coupe selon la date ###
    if TPS==ParamP[ID]['DCOUP']:
      if groupe=='croissance':
        groupe='defoliation'
        dt=0.25
    
    if (TPS==ParamP[ID]['DCOUP']+1.):
      if groupe=='defoliation':
        if ParamP[ID]['DCOUP']+ParamP[ID]['FREQUCOUPE'] < ParamP[ID]['PREMIERCOUPE']+ParamP[ID]['DUREECOUPE']:
          ParamP[ID]['DCOUP']=ParamP[ID]['DCOUP']+ParamP[ID]['FREQUCOUPE']
          print 'prochaine_coupe',ParamP[ID]['DCOUP']
        reprise_coupe=True
        groupe='croissance'
        dt=1
        
    if TPS==ParamP[ID]['DCOUP']+0.75:
      for i in xrange(len(Seuil)):
        for j in xrange(len(Seuil[i])):
          Seuil[i][j]=5.5
    
    ### Declenchement de la coupe selon la taille de la plante ###
    #if TPS>1 and groupe=='croissance':
    #  for x in les_feuilles:
    #    if mtg.property('ParamFeuille').get(x).Taillefeuille>(1.5*ParamP[ID]['HCOUP']):
    #      groupe='defoliation'
    #      dt=0.25
    #      CoupeTaille=TPS
    #      print CoupeTaille
    # 
    #if (TPS==CoupeTaille+1) and groupe=='defoliation':
    #  reprise_coupe=True
    #  groupe='croissance'
    #  dt=1
    
    ### Declenchement de la coupe selon la lumiere transmise ###
    
    ### Declenchement de la coupe selon le LAI ###
    


def EndEach(lstring,lscene):
  global TPS,dt,mtg,Surfoliairetotale,les_pointes,les_primordiums,RootPotentialNewBiomass,les_feuilles,les_feuilles_emergees,les_racines, Reserve,Biomasse_aerienne,Surfoliaireencours,Biomasse_racinaire,simul_expe,fichier_test,groupe,PourcentageRootGrowthRealized,PourcentageFeuilGrowthRealized,Demande_feuille,C,reprise_coupe,Ray,BiomProd,Caribu
  global current_day, meteo, apex_characteristics, internode_characteristics # AJOUT SIMON
  
  TPS=TPS+dt
  print 'TPS :',TPS , 'Current day :', current_day # AJOUT SIMON
  mtg=my_axialtree2mtg(lstring, scales,None, parameters,TREE)
  Activate(mtg)
  
  #if groupe=='croissance':  
  #if TPS==PREMIERCOUPE:
  #  newSB=Biomasse_aerienne-0.221  #TF   0.1591  #TG
  #else:
  newSB=0 #Nouvelle biomasse aerienne
  
  ### Utilisation de Caribu ###  
  if TPS >= 10000 and TPS % 10 == 0:
    Caribu="On"
    timing_method1=t.time()
	#energy, emission, direction, elevation , azimuth  = turtle.turtle()
    #ligthsources = zip(energy,direction)
    ligthsources = [(1, (-0.0, 0.0, -1.0))]
    #ligthsources=r'C:\Python27\Lib\site-packages\alinea.caribu-7.0.0-py2.7-win32.egg\alinea\caribu_wralea\data\zenith.light'
    
    scene=lscene
    for i in xrange(len(scene)-1,-1,-1):
      if lstring[scene[i].getId()].name <> 'Feuille':
        scene.remove(scene[i])
    scene.save(os.path.join(OUTPUTS_DIRPATH,'ma_scene.geom'))
    
    dico_id={}
    counter=0
    for sh in lscene:
      dico_id[counter]=sh.id
      lscene[sh.id].id=counter
      counter+=1
    res=apply_caribu(lstring, lscene, ligthsources)
    print('temps d exec de caribu:',t.time()-timing_method1)
    for id,v in res.items():
      if lstring[dico_id[id]].name == 'Feuille':
        Ray[lstring[dico_id[id]].ParamFeuille.id_plante]+=v
        
    for ID in xrange(nb_plantes):
      Ray[ID]=Ray[ID]/Surfoliairetotale[ID]
      BiomProd[ID]=Ray[ID]*(25*0.48)*2 #0.48=conversion rayonnement global en PAR / 2=RUE / 25=Rayonnement incident
      print('Plante %s, Ray: %s, BiomProd: %s' % (ID, Ray[ID],BiomProd[ID]))
  
  
  for ID in xrange(nb_plantes):
    #print
    #print 'Plante', ID+1
    
    if reprise_coupe==True:
      reprise_coupe=False
    
    les_feuilles=[x for x in VtxList(4) if Class(x)=='F' and mtg.property('ParamFeuille').get(x).id_plante==ID]
    Demande_feuille_dans_gaine[ID]=sum([mtg.property('ParamFeuille').get(x).Besoinencroiss for x in les_feuilles if mtg.property('ParamFeuille').get(x).Phase=='cachee'])
    Demande_feuille_hors_gaine[ID]=sum([mtg.property('ParamFeuille').get(x).Besoinencroiss for x in les_feuilles if mtg.property('ParamFeuille').get(x).Phase!='cachee'])    
    Demande_feuille[ID]=sum([Demande_feuille_dans_gaine[ID],Demande_feuille_hors_gaine[ID]])
    Biomasse_aerienne[ID]=sum([mtg.property('ParamFeuille').get(x).biomass for x in les_feuilles])    
    Surfoliairetotale[ID]=sum([mtg.property('ParamFeuille').get(x).surface for x in les_feuilles])
    
    if Biomasse_aerienne[ID]>0 and t1[ID]*exp(TPS*t2[ID])-t1[ID]>0: #Verifie qu'il y a une partie aerienne et que TPS, t1 et t2 sont positifs
      if Caribu=="On":
        print "On"
        BiomassCree=BiomProd[ID]
      else:
        print "Off"
        BiomassCree=t2[ID]*(Biomasse_aerienne[ID]+t1[ID])*(1+Beta[ID]*Alpha[ID]*(Biomasse_aerienne[ID])**(Alpha[ID]-1))
      if BiomassCree>0 and 0.99*BiomassCree-Demande_feuille[ID]>0:#Next_biom_feuil[ID]-Biomasse_aerienne[ID]>0 and 
        RootBiomassCree=BiomassCree-Demande_feuille[ID]
        Biomasse_racinaire[ID]+=RootBiomassCree
        PourcentageFeuilGrowthRealized[ID]=1
      else:
        RootBiomassCree=0.01*BiomassCree
        Biomasse_racinaire[ID]+=RootBiomassCree
        BiomassFeuilCree=0.99*BiomassCree
        PourcentageFeuilGrowthRealized[ID]=BiomassFeuilCree/Demande_feuille[ID]
        if PourcentageFeuilGrowthRealized[ID]<0:
          PourcentageFeuilGrowthRealized[ID]=0
    else:
      RootBiomassCree=0
      BiomassCree=0
    
    #if TPS<=PREMIERCOUPE:
    #  PourcentageRootGrowthRealized[ID]=1
    #PourcentageFeuilGrowthRealized[ID]=1 #le temps de tester
    
    if RootPotentialNewBiomass[ID]==0:
      PourcentageRootGrowthRealized[ID]=0
      #Reserve[ID]=Reserve[ID]+RootBiomassCree
    else:
      PourcentageRootGrowthRealized[ID]=RootBiomassCree/RootPotentialNewBiomass[ID]
      if PourcentageRootGrowthRealized[ID]>1:
        PourcentageRootGrowthRealized[ID]=1
        #Reserve[ID]=Reserve[ID]+(RootBiomassCree-RootPotentialNewBiomass[ID])
      else:
        if RootPotentialNewBiomass[ID]-RootBiomassCree < Reserve[ID]:
          PourcentageRootGrowthRealized[ID]=1
          #Reserve[ID]=Reserve[ID]-(RootPotentialNewBiomass[ID]-RootBiomassCree)
        else:
          PourcentageRootGrowthRealized[ID]=(RootBiomassCree+Reserve[ID])/RootPotentialNewBiomass[ID]
          #Reserve[ID]=0
    
    #print('PourcentageFeuilGrowthRealized: %s, PourcentageRootGrowthRealized: %s' % (PourcentageFeuilGrowthRealized[ID],PourcentageRootGrowthRealized[ID]))
    #print ('demande feuille: %s, RootPotentialNewBiomass : %s, BiomassCree : %s, RootBiomassCree : %s' % (Demande_feuille[ID], RootPotentialNewBiomass[ID],BiomassCree,RootBiomassCree))
    
    #Biomasse_aerienne[ID]=newSB
    
    #for x in VtxList(5):
    #  if Class(x)=='s':
    #    Biomasse_racinaire=Biomasse_racinaire+(mtg.property('seg').get(x).longueur*P_RootMasseVolumique*pi*(mtg.property('seg').get(x).diametre/2)**2)
    #  elif Class(x)=='t':
    #    Biomasse_racinaire=Biomasse_racinaire+(mtg.property('pte').get(x).longueur*P_RootMasseVolumique*pi/3*(mtg.property('pte').get(x).diametre/2)**2)
  
  #if TPS<PREMIERCOUPE:
  #  PourcentageFeuilGrowthRealized=[1]*(nb_plantes)
  
  #longtotal=0
  #for x in les_racines:
  #  ensemble_de_racine=Components(x)
  #  axe=Path(ensemble_de_racine[0],ensemble_de_racine[len(ensemble_de_racine)-1])
  #  axe.append(ensemble_de_racine[0])
  #  for y in axe:
  #    if Class(y)=='s':
  #      longtotal=longtotal+mtg.property('seg').get(y).longueur
  #    elif Class(y)=='t':
  #      longtotal=longtotal+mtg.property('pte').get(y).longueur
  #  derniere_pointe=ensemble_de_racine[len(ensemble_de_racine)-1]
  
  #Biomasse_aerienne=newSB
  #Surfoliairetotale=Surfoliaireencours
  
  les_feuilles=[x for x in VtxList(4) if Class(x)=='F']
  les_feuilles_emergees=[x for x in VtxList(4) if Class(x)=='F' and mtg.property('ParamFeuille').get(x).Phase!='cachee']
  les_racines=[x for x in VtxList(4) if Class(x)=='r']
  les_pointes=[[mtg.property('pte').get(x).id_pointe,x] for x in VtxList(5) if Class(x)=='t']
  les_pointes2=[x for x in VtxList(5) if Class(x)=='t']
  #les_phytos=[Complex(x) for x in les_feuilles_emergees if Rank(Complex(x))==0]
  #les_primordiums=[x for x in VtxList(5) if Class(x)=='S']
  #les_longs=les_longs2
  
  nb_feuilles=[0]*nb_plantes
  nb_talles_emergees=[0]*nb_plantes
  
  ##### Remplissage du fichier surface_biomass #####
  for x in les_feuilles_emergees:
    if mtg.property('ParamFeuille').get(x).id_rang==1:
      nb_talles_emergees[mtg.property('ParamFeuille').get(x).id_plante]+=1
      ordre=Order(Complex(x)) 
      les_feuilles_dans_talle=[y for y in les_feuilles_emergees if mtg.property('ParamFeuille').get(y).id_plante==mtg.property('ParamFeuille').get(x).id_plante and mtg.property('ParamFeuille').get(y).id_talle==mtg.property('ParamFeuille').get(x).id_talle]
      surface_biomass.writerow([TPS,Espacement,Densite,mtg.property('ParamFeuille').get(x).id_plante+1,mtg.property('ParamFeuille').get(x).coupe,mtg.property('ParamFeuille').get(x).id_talle+1,ordre+1,len(les_feuilles_dans_talle),Biomasse_aerienne[ID],Surfoliairetotale[ID]])

    
    #for x in les_racines:
    #  ensemble_de_racine=Components(x)
    #  axe=Path(ensemble_de_racine[0],ensemble_de_racine[len(ensemble_de_racine)-1])
    #  axe.append(ensemble_de_racine[0])
    #  nb_tip=[x for x in axe if Class(x)=='t']
    #  if len(nb_tip)>1:
    #    print('probleme !!!!!!!!!!!!!!!!!!!!!!!')
    #  long=0
    #  for y in axe:
    #    if Class(y)=='s':
    #      long=long+mtg.property('seg').get(y).longueur
    #    elif Class(y)=='t':
    #      long=long+mtg.property('pte').get(y).longueur
    #  pointe=axe[len(axe)-2]
    #  if mtg.property('pte').get(pointe).diametre<0.52:
    #    print 'probleme racine'
    #    print axe
    #    print ensemble_de_racine
  
  
  
  ##### Remplissage du fichier sortie_simul #####
  
  #les_feuilles_emergees=[]
  #les_feuilles_emergees.append(len([x for x in VtxList(4) if Class(x)=='F' and mtg.property('ParamFeuille').get(x).Phase!='cachee' and mtg.property('ParamFeuille').get(x).id_plante==0]))
  #les_feuilles_emergees.append(len([x for x in VtxList(4) if Class(x)=='F' and mtg.property('ParamFeuille').get(x).Phase!='cachee' and mtg.property('ParamFeuille').get(x).id_plante==1]))
  #talles=[]
  #les_feuilles2=[]
  #les_feuilles2.append(len([x for x in VtxList(4) if Class(x)=='F' and mtg.property('ParamFeuille').get(x).id_plante==0]))
  #les_feuilles2.append(len([x for x in VtxList(4) if Class(x)=='F' and mtg.property('ParamFeuille').get(x).id_plante==1]))
  #talles.append(len([x for x in VtxList(4) if Class(x)=='F' and mtg.property('ParamFeuille').get(x).Phase!='cachee' and mtg.property('ParamFeuille').get(x).id_rang==1 and mtg.property('ParamFeuille').get(x).id_plante==0]))
  #talles.append(len([x for x in VtxList(4) if Class(x)=='F' and mtg.property('ParamFeuille').get(x).Phase!='cachee' and mtg.property('ParamFeuille').get(x).id_rang==1 and mtg.property('ParamFeuille').get(x).id_plante==1]))
  
  #for x in [x for x in VtxList(2) if Class(x)=='P']:
  #tab=[]
  #display_mtg(mtg, x,tab)
  #filename='E:/Projets/ESIP/2016-2017/Plant_Model/essai display.mtg'
  #plantes=[x for x in VtxList(2) if Class(x)=='P']
  
  #  if les_racines<>[]:
  #    plante1=mtg.sub_mtg(les_racines[0])
  #    print('root',les_racines[0])
  #    f=open(filename, 'w')
  #    #properties=[(p, 'REAL') for p in plante1.property_names() if p not in ['edge_type', 'index', 'label']]
  #    mtg_lines=write_mtg(plante1)#,properties)
  #    f.write(mtg_lines)
  #    f.close()
  #Next_biom_feuil=[0]*(nb_plantes)
  
  #if TPS>5:
  #  print('talllage',nb_talle[0],nb_talle[1])
  
  #for ID in xrange(nb_plantes):
  #  nb_feuilles_emergees[ID]=les_feuilles_emergees[ID]
  
  #print
  #for ID in xrange(nb_plantes):
  #  print('Plante %s, surface foliaire : %.2f mm², Biomasse_aerienne : %s' % (ID+1,Surfoliairetotale[ID],Biomasse_aerienne[ID]))
  
  
  
  
  #### AJOUT SIMON ####
  if TPS >= meteo[meteo.id_day == current_day].thermal_time_cumul.iloc[0]:
    current_day += 1    # Next_day
  
  
  
  ##### Remplissage du fichier apex_characteristics #####
    for shape in lscene:
      if (lstring[shape.id].name == 'apex'):
        apex = lstring[shape.id][0]
        apex_characteristics.writerow([current_day, TPS, apex.id_plante, apex.id_talle, apex.id_rang, apex.total_emerged_leaf, apex.total_created_leaves, apex.primary_induction_index, apex.phenological_state, apex.primordia_number, apex.potential_leaf_number, apex.approx_final_leaf_number, apex.final_leaf_number])
      elif (lstring[shape.id].name == 'Entrenoeud'):
        internode = lstring[shape.id][0]
        internode_characteristics.writerow([current_day, TPS, internode.id_plante, internode.id_talle, internode.id_rang, internode.internode_type, internode.length])




def End(lstring,lscene): #Ecriture et fermeture des fichiers de sortie
  global TPS,timing,chemin_fichier1,chemin_fichier2,chemin_fichier3,mtg,long_root,taille_finale_feuille, les_racines, apex_characteristics, internode_characteristics
  
  ### Remplissage du fichier taille_finale_feuille ###
  for ID in xrange(nb_plantes):
    for x in les_feuilles_emergees:
      if mtg.property('ParamFeuille').get(x).id_plante==ID and mtg.property('ParamFeuille').get(x).Phase=='mature':
        taille_finale_feuille.writerow([TPS,Espacement,Densite,ID+1,mtg.property('ParamFeuille').get(x).id_talle+1,mtg.property('ParamFeuille').get(x).id_rang+1, mtg.property('ParamFeuille').get(x).Phase,mtg.property('ParamFeuille').get(x).Taillefeuille,mtg.property('ParamFeuille').get(x).Taillegaine,mtg.property('ParamFeuille').get(x).Taillelimbe])
  
  ##### Remplissage du fichier sortie_simul_ValidCoupe #####  
  nb_feuilles=[0]*nb_plantes
  nb_talles_emergees=[0.]*nb_plantes
  nb_feuilles_talle1=[0.]*nb_plantes
  nb_feuilles_talle2=[0.]*nb_plantes
  nb_feuilles_talle3=[0.]*nb_plantes
  
  for x in les_feuilles_emergees:
    nb_feuilles[mtg.property('ParamFeuille').get(x).id_plante]+=1
    #Nombre de talles emmergees
    if mtg.property('ParamFeuille').get(x).id_rang==1:
      nb_talles_emergees[mtg.property('ParamFeuille').get(x).id_plante]+=1
    #Nombre de feuille presente sur chacun des 3 premiers talles
    if mtg.property('ParamFeuille').get(x).id_talle==0:
      nb_feuilles_talle1[mtg.property('ParamFeuille').get(x).id_plante]+=1
    if mtg.property('ParamFeuille').get(x).id_talle==1:
      nb_feuilles_talle2[mtg.property('ParamFeuille').get(x).id_plante]+=1
    if mtg.property('ParamFeuille').get(x).id_talle==2:
      nb_feuilles_talle3[mtg.property('ParamFeuille').get(x).id_plante]+=1
  
  nb_racines=[0]*nb_plantes
  nb_racines_visible=[0]*nb_plantes
  longroottotal=[0]*nb_plantes
  longueurtotale=[0]*nb_plantes
  profond=[0]*nb_plantes
  
  if OptionRacine!='SansRacines':
    for x in les_racines:
      long=0
      ensemble_de_racine=Components(x)
      ID=mtg.property('ParamRacine').get(x).id_plante
      
      for y in ensemble_de_racine:
        if Class(y)=='s':
          longueurtotale[ID]+=mtg.property('seg').get(y).longueur
        elif Class(y)=='t':
          longueurtotale[ID]+=mtg.property('pte').get(y).longueur
      axe=Path(ensemble_de_racine[0],ensemble_de_racine[len(ensemble_de_racine)-1])
      axe.append(ensemble_de_racine[0])
      
      for y in axe:
        if Class(y)=='s':
          long=long+mtg.property('seg').get(y).longueur
        elif Class(y)=='t':
          long=long+mtg.property('pte').get(y).longueur
      longroottotal[mtg.property('ParamRacine').get(x).id_plante]+=long
      nb_racines[mtg.property('ParamRacine').get(x).id_plante]+=1
      if long>5:
        nb_racines_visible[mtg.property('ParamRacine').get(x).id_plante]+=1
      pointe=axe[len(axe)-2]
      profond[mtg.property('ParamRacine').get(x).id_plante]=max(profond[mtg.property('ParamRacine').get(x).id_plante],mtg.property('pte').get(pointe).profondeur)
  
  for ID in xrange(nb_plantes):
    simul_expe.writerow([TPS,Espacement,Densite,ParamP[ID]['C'],ID+1,nb_feuilles[ID],nb_talles_emergees[ID],nb_feuilles_talle1[ID],nb_feuilles_talle2[ID],nb_feuilles_talle3[ID]])
  
  ### Fermeture des fichiers ###
  chemin_fichier1.close()
  chemin_fichier2.close()
  chemin_fichier3.close()
  
  ### Sauvegarde d'une image de la scene
  outimagepath = os.path.join(OUTPUTS_DIRPATH, outimage)
  frameDisplay(True)
  Viewer.display(lscene)
  Viewer.camera.lookAt((800,400,100),(0,0,0)) #Pas la meme capture si pris avec lpy ou avec batch
  Viewer.frameGL.setSize(1200,800) #Taille de la fenetre
  Viewer.frameGL.saveImage(outimagepath)
  Viewer.stop()
  
  #print(lstring)
  print 'Execution time :',t.time()-timing



def FoncCroiss(t, Ymax, tend, tmax): # fonction de croissance de feuille
  if (t>tend):
    y=Ymax
  else:
    y=Ymax*(1+((tend-t)/(tend-tmax)))*(pow((t/tend),(tend/(tend-tmax))))
  return y

#def TpourY(Y, Ym, Te, Tm):  # retrouver le temps T auquel la taille de la feuille valait Y
#  L=0
#  i=0
#  if Y>Ym:
#    return Te
#  else:
#    while L<Y:
#      L=FoncCroiss(i, Ym, Te, Tm)
#      i=i+1
#    j=max(i-1,0)
#    L=FoncCroiss(j, Ym, Te, Tm)
#    
#    while L<=Y:
#      L=FoncCroiss(j, Ym, Te, Tm)
#      j=j+0.1
#    k=max(j-1,0)
#    L=FoncCroiss(k, Ym, Te, Tm)
#    
#    while L<=Y:
#      L=FoncCroiss(k, Ym, Te, Tm)
#      k=k+0.01
#    l=max(k-1,0)
#    L=FoncCroiss(l, Ym, Te, Tm)
#    
#    while L<=Y:
#      L=FoncCroiss(l, Ym, Te, Tm)
#      l=l+0.001
#    return max(l-0.001,0)

def TpourY2(Y, Ym, Te, Tm):  # retrouver le temps T auquel la taille de la feuille valait Y
  curs1=0
  curs2=Te
  newt=Te/2
  while curs2-curs1>0.001:
    newt=curs1+(curs2-curs1)/2
    L=FoncCroiss(newt, Ym, Te, Tm)
    if L==Y:
      return newt
    elif L<Y:
      curs1=newt
    else:
      curs2=newt
  return curs1+(curs2-curs1)/2




Axiom: CouvertVegetal(0)

derivation length: DureeExp


production:

GetPos(a,b,c)<SegFeuille(X):
  X.hauteur=c
  produce SegFeuille(X)


GetPos(a,b,c)<tip(X):
  X.profondeur=-c
  produce tip(X)


CouvertVegetal(X):
  global groupe,NBlignes,NBcolonnes,genotype
  if groupe=='croissance':
    if X==1:
      nproduce CouvertVegetal(2)
      for i in xrange(NBlignes):
        for j in xrange(NBcolonnes):
          id_plante=i*NBcolonnes+j
          geno=i
          genotype.append(geno)
          param=ParamPlante(id_plante,geno)
          nb_talle.append(0)
          nproduce IN SB() RollR(45) MoveTo(j*Espacement,Espacement*i,0) Plante(param) IN EB()
    else:
      produce CouvertVegetal(X+1)
  if groupe=='defoliation':
    produce CouvertVegetal(X)


Plante(X):
  global TPS,groupe, current_day
  if groupe=='croissance':
    if TPS ==2:
      Seuil.append([5.5])
      Taille_finale_gaine.append([[5.5,5.5]])
      Y1=ParamPhytomere(id_plante=X.id_plante)
      YF=ParamFeuille(age=0,Agecroiss=0,Taillefeuille=0,id_plante=X.id_plante,id_rang=1,Ymax=Premiecroiss[X.id_plante],Taillefinalelimbe=0.8*Premiecroiss[X.id_plante],Taillefinalegaine=0.2*Premiecroiss[X.id_plante])
      Yb=ParambourgeonRoot(X.id_plante,id_talle=0,id_rang=1)
      YAT=ParamApexTal(X.id_plante,id_talle=0,id_rang=1)
      YA=ParamApex(X.id_plante,id_talle=0,id_rang=1)
      YINT=ParamEntrenoeud(X.id_plante,id_talle=0,id_rang=1)      # AJOUT SIMON
      produce Plante(X) phytomere(Y1, YA) RollR(95) bourgeonRoot(Yb, YINT) ApexTal(YAT) Entrenoeud(YINT, YA, YF) FLW SB Feuille(YF, YA) FLW EB apex(YA)
  if groupe=='defoliation':
    produce Plante(X)


phytomere(X, X_AP):
  global groupe
  if groupe=='croissance':
    X.age=X.age+1
    if (X.id_talle!=0 and X.id_rang==0):
      if (X.age>=120 and X.angletal<=ParamP[X.id_plante]['divergetalle']):
        X.angletal=X.angletal+(1./3.)
  if groupe=='defoliation':
    produce phytomere(X, X_AP)


Feuille(X, X_apex):
  global mtg,NewShootBiomass,longueur_totale_feuille,les_feuilles,Surfoliaireencours,groupe
  X.surface=0
  
  if groupe=='croissance':
    X.age=X.age+1  
    vtx_feuille=[x for x in les_feuilles if (mtg.property('ParamFeuille').get(x).id_plante==X.id_plante and mtg.property('ParamFeuille').get(x).id_talle==X.id_talle and mtg.property('ParamFeuille').get(x).id_rang==X.id_rang)][0]  # vertex de la feuille
    vtx_feuille_precedente=[x for x in les_feuilles if (mtg.property('ParamFeuille').get(x).id_plante==X.id_plante and mtg.property('ParamFeuille').get(x).id_talle==X.id_talle and mtg.property('ParamFeuille').get(x).id_rang==X.id_rang-1)]
    
    if(X.angleinsert<=ParamP[X.id_plante]['INSERTIONLIMBE'] and X.Taillegaine>Taille_finale_gaine[X.id_plante][X.id_talle][X.id_rang-1] +1):
      X.angleinsert=X.angleinsert+1    
    
    Seuil[X.id_plante][X.id_talle]=max(Seuil[X.id_plante][X.id_talle],X.Taillegaine)
    Taille_finale_gaine[X.id_plante][X.id_talle][X.id_rang]=max(Taille_finale_gaine[X.id_plante][X.id_talle][X.id_rang],X.Taillegaine)
    plante=Complex(vtx_feuille,2)
    
    if X.Phase!='mature':
      ##### Modif potentiel apres coupe ######
      if reprise_coupe==True and X.Phase=='visible':
        genotype=mtg.property('ParamPlante').get(plante).id_geno
        LEDGAINE=((0.2*110*5)*2)-110
        TrueAge=TpourY2(Seuil[X.id_plante][X.id_talle],paramManagement['YFinit'], paramManagement['Jled']*LEDGAINE,paramManagement['Kled']*paramManagement['Jled']*LEDGAINE) #Jled*LEDGAINE correspond a te, Kled*Jled*LEDGAINE correspond a tm (These Alban Verdenal)
        NewYmax=ParamP[X.geno]['C']*((pow(paramManagement['T01'],(TrueAge+paramManagement['tb1'])*paramManagement['k1'])-paramManagement['Lpot'])-(pow(paramManagement['T02'],(TrueAge+paramManagement['tb2'])*paramManagement['k2'])))
        if NewYmax>X.Ymax:
          NewYmax=X.Ymax
        elif NewYmax<X.Taillefeuille+X.coupe:
          X.Phase='mature'
        else:
          #LED1=((X.Taillefinalegaine*5)*2)-X.Ymax
          NewTaillefinaleg=X.rapportK * NewYmax
          LED2=((NewTaillefinaleg*5)*2)-NewYmax
          X.Difftps=TpourY2(X.Taillefeuille+X.coupe,NewYmax,paramManagement['Jled']*LED2,paramManagement['Kled']*paramManagement['Jled']*LED2)-X.age
          #TpourY2(Seuil[X.id_plante][X.id_talle], X.Ymax,paramManagement['Jled']*LED,paramManagement['Kled']*paramManagement['Jled']*LED)-X.age#TpourY2(X.Taillefeuille+X.coupe,paramManagement['YFinit'], paramManagement['Jled']*LEDGAINE,paramManagement['Kled']*paramManagement['Jled']*LEDGAINE)
          X.Agecroiss=X.Difftps+X.age
          X.Ymax=NewYmax
        
        X.Taillefinalelimbe=(1-X.rapportK)*X.Ymax
        X.Taillefinalegaine=X.rapportK*X.Ymax
      
      ###### Gestion passage phase cachee a phase visible ######
      if X.Phase=='cachee':
        if X.Taillefeuille > Seuil[X.id_plante][X.id_talle]:
          X.Phase='visible'
          X_apex.total_emerged_leaf += 1                                                      # Ajoute une feuille visible a l apex
          Seuil[X.id_plante][X.id_talle] *= 1.15
          LEDGAINE=((0.2*Premiecroiss[X.id_plante]*5)*2)-Premiecroiss[X.id_plante]
          X.TailleEmergence=Seuil[X.id_plante][X.id_talle]
          TrueAge=TpourY2(X.Taillefeuille+X.coupe,Premiecroiss[X.id_plante], paramManagement['Jled']*LEDGAINE,paramManagement['Kled']*paramManagement['Jled']*LEDGAINE)
          
          genotype=mtg.property('ParamPlante').get(plante).id_geno
          X.Ymax=ParamP[genotype]['C']*((pow(paramManagement['T01'],(TrueAge+paramManagement['tb1'])*paramManagement['k1'])-paramManagement['Lpot'])-(pow(paramManagement['T02'],(TrueAge+paramManagement['tb2'])*paramManagement['k2']))); #Alban
          #X.Ymax=ParamP[genotype]['C']*(1*exp(0.032*(TrueAge+paramManagement['tb1']))-1*exp(0.047*(TrueAge+paramManagement['tb2']))-paramManagement['Lpot'])  #TF
          
          #else:
          #  X.Ymax=0.7*(1*exp(0.0110422966*(TrueAge+772.67636741))-1*exp(0.0113550477*(TrueAge+743.16065674))-602.78369237) #C=0.7
          #  #X.Ymax=(1*exp(0.0250863392*(TrueAge+200.53615212))-1*exp(0.0280890692*(TrueAge+160.2264956))-129.08189529)  #TG
          #  #X.Ymax= 1*exp(0.0251*((X.age-1)+200.1))-1*exp(0.0281*((X.age-1)+158.9))-129.1  #TG
          #X.Ymax= ((pow(paramManagement['T01'],((X.age-1)+paramManagement['tb1'])*paramManagement['k1'])-paramManagement['Lpot'])-(pow(paramManagement['T02'],((X.age-1)+paramManagement['tb2'])*paramManagement['k2'])))   # FL
          #X.Ymax= 0.85*((pow(paramManagement['T01'],((X.age-1)+paramManagement['tb1'])*paramManagement['k1'])-paramManagement['Lpot'])-(pow(paramManagement['T02'],((X.age-1)+paramManagement['tb2'])*paramManagement['k2'])))   # New FC
          #X.Ymax=0.55*((615*pow(paramManagement['T01'],X.age*0.0053))-736.9-(0.1207*pow(paramManagement['T02'],X.age*0.062)))   # FC
          X.rapportK=0.1+((TrueAge-1)/600.)
          X.Taillefinalelimbe=(1-X.rapportK)*X.Ymax
          X.Taillefinalegaine=X.Ymax*X.rapportK
          
          LED=((X.Taillefinalegaine*5)*2)-X.Ymax
          #LEDGAINE=((0.2*110*5)*2)-110
          X.Difftps=TpourY2(Seuil[X.id_plante][X.id_talle], X.Ymax,paramManagement['Jled']*LED,paramManagement['Kled']*paramManagement['Jled']*LED)-X.age#TpourY2(X.Taillefeuille+X.coupe,110, paramManagement['Jled']*LEDGAINE,paramManagement['Kled']*paramManagement['Jled']*LEDGAINE)
          X.AgeCroiss=X.age+X.Difftps#TpourY(X.Taillefeuille, X.Ymax ,paramManagement['Jled']*(((X.Ymax/0.2)*(0.2+((X.age/(60.*10.))-0.1))*2.)-X.Ymax),paramManagement['Kled']*paramManagement['Jled']*(((X.Ymax/0.2)*(0.2+((X.age/(60.*10.))-0.1))*2.)-X.Ymax))
      
      ###### croissance ######
      LEDGAINE=((X.Taillefinalegaine*5)*2)-X.Ymax
      Accroiss=0
      #if (X.Taillegaine< Taille_finale_gaine[X.id_plante][X.id_talle][X.id_rang-1] +13):
      inversea=TpourY2(X.Taillefeuille+X.coupe, X.Ymax, paramManagement['Jled']*LEDGAINE,paramManagement['Kled']*paramManagement['Jled']*LEDGAINE)
      
      if(X.Phase=='cachee'):
        inversea=TpourY2(X.Taillefeuille+X.coupe, X.Ymax, paramManagement['Jled']*LEDGAINE,paramManagement['Kled']*paramManagement['Jled']*LEDGAINE)
        AccroissDemande=FoncCroiss(inversea+1, X.Ymax, paramManagement['Jled']*LEDGAINE, paramManagement['Kled']*paramManagement['Jled']*LEDGAINE)-FoncCroiss(inversea, X.Ymax, paramManagement['Jled']*LEDGAINE, paramManagement['Kled']*paramManagement['Jled']*LEDGAINE)
        #Accroiss=FoncCroiss(X.age, X.Ymax, paramManagement['Jled']*LEDGAINE, paramManagement['Kled']*paramManagement['Jled']*LEDGAINE)-FoncCroiss(X.age-1, X.Ymax, paramManagement['Jled']*LEDGAINE, paramManagement['Kled']*paramManagement['Jled']*LEDGAINE)
        X.Agecroiss=X.age
      if(X.Phase=='visible'):
        #AccroissDemande=(FoncCroiss(inversea+1, X.Ymax, paramManagement['Jled']*LEDGAINE, paramManagement['Kled']*paramManagement['Jled']*LEDGAINE)-FoncCroiss(inversea, X.Ymax, paramManagement['Jled']*LEDGAINE, paramManagement['Kled']*paramManagement['Jled']*LEDGAINE))*PourcentageFeuilGrowthRealized[mtg.property('ParamPlante').get(plante).id_plante]
        AccroissDemande=(FoncCroiss(X.Agecroiss+1, X.Ymax, paramManagement['Jled']*LEDGAINE, paramManagement['Kled']*paramManagement['Jled']*LEDGAINE)-FoncCroiss(X.Agecroiss, X.Ymax, paramManagement['Jled']*LEDGAINE, paramManagement['Kled']*paramManagement['Jled']*LEDGAINE))
        X.Agecroiss=X.age+X.Difftps
      Pourcent=PourcentageFeuilGrowthRealized[mtg.property('ParamPlante').get(plante).id_plante]
      
      if(X.Phase=='mature'):
        AccroissDemande=0
      
      if Pourcent==1:
        Accroiss=AccroissDemande
      else:
        if AccroissDemande<=0.02:
          Accroiss=AccroissDemande
        else:
          Accroiss=DetermineAccroiss(Pourcent,X,AccroissDemande)
      
      if (X.Taillegaine>0.98*X.Taillefinalegaine and X.Taillegaine<=Taille_finale_gaine[X.id_plante][X.id_talle][X.id_rang-1] -5 and X.Phase=='visible'):
        Accroiss=1
      
      #if (X.Taillegaine>=Taille_finale_gaine[X.id_plante][X.id_talle][X.id_rang-1]  +13 and X.Phase=='visible'):
      #  Accroiss=0
      
      #taillefictive=TpourY()
      limbefictif=0.973*FoncCroiss(X.Agecroiss-1, X.Ymax, paramManagement['Jled']*LEDGAINE, paramManagement['Kled']*paramManagement['Jled']*LEDGAINE)
      
      if X.R==0.973 and limbefictif>(0.75*X.Taillefinalelimbe):
        X.R=0.965
      if X.R==0.965 and limbefictif>X.Taillefinalelimbe:
        X.R=0
      #R=0
      #if ((X.Taillelimbe+X.coupe)<(0.75*X.Taillefinalelimbe)):
      #  R=0.973
      #if (((X.Taillelimbe+X.coupe)>(0.75*X.Taillefinalelimbe)) and ((X.Taillelimbe+X.coupe)<X.Taillefinalelimbe)):
      #  R=0.965
      
      if X.Cutstatus!='entierementcoupee': #le limbe n'est pas entierement coupe
        X.Taillefeuille=X.Taillefeuille+Accroiss
        X.Taillelimbe=X.Taillelimbe+Accroiss*X.R
        X.Taillegaine=X.Taillegaine+Accroiss*(1-X.R)
      else:
        X.Taillegaine=X.Taillegaine+Accroiss*(1-X.R)
        X.Taillefeuille=X.Taillefeuille+Accroiss*(1-X.R)
      
      if Accroiss==0:
        X.Besoinencroiss=0
        X.Phase='mature'
      
      X.biomass=BiomassFeuille(X.Taillefeuille,X.coupe,X.geno)
      
      if X.Phase!='mature':
        if (X.Taillegaine< Taille_finale_gaine[X.id_plante][X.id_talle][X.id_rang-1] +13):
          inversea=TpourY2(X.Taillefeuille+X.coupe, X.Ymax, paramManagement['Jled']*LEDGAINE,paramManagement['Kled']*paramManagement['Jled']*LEDGAINE)
        
        if(X.Phase=='cachee'):
          NextAccroiss=FoncCroiss(X.age+1, X.Ymax, paramManagement['Jled']*LEDGAINE, paramManagement['Kled']*paramManagement['Jled']*LEDGAINE)-FoncCroiss(X.age, X.Ymax, paramManagement['Jled']*LEDGAINE, paramManagement['Kled']*paramManagement['Jled']*LEDGAINE)
          #X.Agecroiss=X.age
        
        if(X.Phase=='visible'):
          NextAccroiss=(FoncCroiss(X.Agecroiss+1, X.Ymax, paramManagement['Jled']*LEDGAINE, paramManagement['Kled']*paramManagement['Jled']*LEDGAINE)-FoncCroiss(X.Agecroiss, X.Ymax, paramManagement['Jled']*LEDGAINE, paramManagement['Kled']*paramManagement['Jled']*LEDGAINE))         
          #X.Agecroiss=X.age+X.Difftps
        
        if mtg.property('ParamPlante').get(plante).id_geno==0:
          long=X.Taillefeuille+NextAccroiss
          Next_feuil=BiomassFeuille(long,X.coupe,X.geno)
        
        else:
          long=X.Taillefeuille+NextAccroiss
          Next_feuil=BiomassFeuille(long,X.coupe,X.geno)
        X.Besoinencroiss=Next_feuil-X.biomass
        #Next_biom_feuil[mtg.property('ParamPlante').get(plante).id_plante]=Next_biom_feuil[mtg.property('ParamPlante').get(plante).id_plante]+Next_feuil
      #NewShootBiomass=NewShootBiomass+Accroiss*0.0001
      
      ####### Senescence #######
      ##Agesenesc=paramManagement['T0sen']*10000.+(X.Ymax/20.)*paramManagement['Lpot']. 
      ##if (X.age>Agesenesc+100.):
      ##  produce Cut() # Pour que la feuille soit vraiment coupee supprimee de la chaine, en ENTIER
      ##else:
    
    else:      
      if mtg.property('ParamPlante').get(plante).id_geno==0:
        long=X.Taillefeuille
        coupe=X.coupe
        Next_feuil=paramManagement['FacBiom1']*(paramManagement['b0']*exp(paramManagement['b1']*(long+coupe)**2+paramManagement['b2']*(long+coupe))-paramManagement['b0'])*(long/(long+coupe))
      else:
        long=X.Taillefeuille
        coupe=X.coupe
        Next_feuil=paramManagement['FacBiom1']*(paramManagement['b0']*exp(paramManagement['b1']*(long+coupe)**2+paramManagement['b2']*(long+coupe))-paramManagement['b0'])*(long/(long+coupe))
        #Next_feuil=1.554*(paramManagement['b0']*exp(paramManagement['b1']*(long)**2+paramManagement['b2']*(long))-paramManagement['b0'])*(long/(long+X.coupe))
      #Next_biom_feuil[mtg.property('ParamPlante').get(plante).id_plante]=Next_biom_feuil[mtg.property('ParamPlante').get(plante).id_plante]+Next_feuil
    # La feuille est ecartee par une autre talle
    phytos_suivant=Sons(Complex(vtx_feuille))
    if phytos_suivant!=[]:
      phyto_suivant=phytos_suivant[len(phytos_suivant)-1]
      if len(Sons(phyto_suivant))>1:
        phyto_entrainant=Sons(phyto_suivant)[0]
        X.angletal=mtg.property('ParamPhytomere').get(phyto_entrainant).angletal
    longueur_totale_feuille=longueur_totale_feuille+X.Taillefeuille
    
    if (X.Phase!='cachee'):
      Taillepointelineraire=ParamP[X.id_plante]['Taillepointelineraire']
      numstepsg=ceil((X.Taillegaine)/LSTEP)
      if X.Cutstatus!='entierementcoupee':
        numsteps=ceil((X.Taillefeuille)/LSTEP)
      else:
        numsteps=ceil((X.Taillegaine)/LSTEP)
      
      for i in xrange(int(numsteps)):
        if (i>=numstepsg-1):
          taille=X.Taillelimbe+X.coupe
          L0=X.Taillefinalelimbe-taille
          if ((i-numstepsg)<((taille-Taillepointelineraire)/LSTEP)):
            large=(paramManagement['CoefSecondDegreLonLar']*pow(((L0+((i-numstepsg)*LSTEP))/X.Taillefinalelimbe), 2)+paramManagement['CoefPremierDegreLonLar']*((L0+((i-numstepsg)*LSTEP))/X.Taillefinalelimbe)+paramManagement['ConstantLonLar'])*(((paramManagement['CoefDirLonLarAjust']*log(X.Ymax))-paramManagement['OrdOriLonLarAjust'])/2)
          else:
            largini=(paramManagement['CoefSecondDegreLonLar']*pow(((L0+(((i-numstepsg)-1)*LSTEP))/X.Taillefinalelimbe), 2)+paramManagement['CoefPremierDegreLonLar']*((L0+(((i-numstepsg)-1)*LSTEP))/X.Taillefinalelimbe)+paramManagement['ConstantLonLar'])*(((paramManagement['CoefDirLonLarAjust']*log(X.Ymax))-paramManagement['OrdOriLonLarAjust'])/2)
            large=largini-(((i-numstepsg)-((taille-Taillepointelineraire)/LSTEP))*((largini*LSTEP)/Taillepointelineraire))
          if(i<numstepsg-1):
            large=0.
          
          Surfoliaireencours[X.id_plante]=Surfoliaireencours[X.id_plante]+large*2.*LSTEP  
          X.surface=X.surface+large*2.*LSTEP  
      
      largegaine=max((2/pi)*(paramManagement['CoefDirLonLarAjust']*log(max(X.Taillegaine*5,1))-paramManagement['OrdOriLonLarAjust']),0.1)
      X.surface+=largegaine*pi*X.Taillegaine
      produce Feuille(X, X_apex)
  
  ##### Coupe des feuilles #####
  if groupe=='defoliation':
    Torsiongaine=ParamP[X.id_plante]['Torsiongaine']   
    curve=ParamP[X.id_plante]['curve']*LSTEP
    
    ### Creation de la doublure de la plante ###
    if TPS==ParamP[X.id_plante]['DCOUP']:
      nproduce Feuille(X, X_apex) IN SB
      
      if (X.Phase=='cachee'):
        numsteps=(X.Taillefeuille-X.coupe)/LSTEP
        for i in range(int(numsteps)):
          PS=ParamSegFeuille(X.id_plante,idLong=i,hauteur=0)
          rank=X.id_rang
          if(i<(10/LSTEP)):
            nproduce  Down(Torsiongaine*pow(-1,rank)) GetPos(0,0,0) SegFeuille(PS)
          if(i>=(10/LSTEP)):
            nproduce GetPos(0,0,0) SegFeuille(PS)
      
      if (X.Phase!='cachee'):
        if X.Cutstatus!='entierementcoupee':
          numsteps=ceil((X.Taillefeuille)/LSTEP)
        else:
          numsteps=ceil((X.Taillegaine)/LSTEP)
        numstepsg=ceil((X.Taillegaine)/LSTEP)
        
        for i in range(int(numsteps)):
          PS=ParamSegFeuille(X.id_plante,idLong=i,hauteur=0)
          rank=X.id_rang
          if (i<numstepsg-1):
            if(i<(10/LSTEP)):
              nproduce Down(Torsiongaine*pow(-1,rank))GetPos(0,0,0)SegFeuille(PS)
            else:
              nproduce GetPos(0,0,0)SegFeuille(PS)
          
          else:
            if(i==numstepsg):
              if X.id_rang>4:
                pseudotige=max([Taille_finale_gaine[X.id_plante][X.id_talle][x] for x in xrange(X.id_rang-3,X.id_rang-1)])
              else:
                pseudotige=Taille_finale_gaine[X.id_plante][X.id_talle][X.id_rang-1]
              if (X.Taillegaine > pseudotige):
                nproduce Left(X.angleinsert)GetPos(0,0,0)SegFeuille(PS)
            
            if ((i>numsteps-2) and X.coupe>2):         # /* Pour avoir cicatrice au bout feuille coupees */
              if i<numstepsg:
                if X.Cutstatus=='entierementcoupee':
                  nproduce GetPos(0,0,0)SegFeuille(PS)
                else:
                  nproduce RollR(0)Left(curve)GetPos(0,0,0)SegFeuille(PS)
              else:
                nproduce RollR(0)Left(curve)GetPos(0,0,0)SegFeuille(PS)
            
            if(X.id_rang==1 and X.id_talle>0):
              if (i>(X.TailleEmergence-2)/LSTEP):
                nproduce RollR(0)Left(curve)GetPos(0,0,0)SegFeuille(PS)
              
              if (i<(X.TailleEmergence-2)/LSTEP):
                if(i<(10/LSTEP)):
                  nproduce  Down(Torsiongaine*pow(-1,rank))GetPos(0,0,0)SegFeuille(PS)
                else:
                  nproduce GetPos(0,0,0)SegFeuille(PS)
            
            else:
              if X.id_rang>4:
                pseudotige=max([Taille_finale_gaine[X.id_plante][X.id_talle][x] for x in xrange(X.id_rang-3,X.id_rang-1)])
              else:
                pseudotige=Taille_finale_gaine[X.id_plante][X.id_talle][X.id_rang-1]
              
              if (i>pseudotige/LSTEP):
                if i<numstepsg:
                  if X.Cutstatus=='entierementcoupee':
                    nproduce GetPos(0,0,0)SegFeuille(PS)
                  else:
                    nproduce RollR(0)Left(curve)GetPos(0,0,0)SegFeuille(PS)
                else:
                  nproduce RollR(0)Left(curve)GetPos(0,0,0)SegFeuille(PS)
              
              if (i<=pseudotige/LSTEP):
                if(i<(10/LSTEP)):
                  nproduce  Down(Torsiongaine*pow(-1,rank))GetPos(0,0,0)SegFeuille(PS)
                else:
                  nproduce GetPos(0,0,0)SegFeuille(PS)
      produce IN EB
    
    ### Realisation de la coupe ###
    elif TPS==ParamP[X.id_plante]['DCOUP']+0.5: 
        vtx_feuille=[x for x in les_feuilles if (mtg.property('ParamFeuille').get(x).id_plante==X.id_plante and mtg.property('ParamFeuille').get(x).id_talle==X.id_talle and mtg.property('ParamFeuille').get(x).id_rang==X.id_rang)][0]
        longcoupee=LongueurFeuilleCoupee(vtx_feuille,X.id_plante)
        if longcoupee<>-1:
          X.coupe=X.Taillefeuille-longcoupee
          X.Taillefeuille=longcoupee
          if X.Taillefeuille<X.Taillegaine:
            X.Taillegaine=X.Taillefeuille
            X.Taillelimbe=0
            X.Cutstatus='entierementcoupee'
          else:
            X.Taillelimbe=X.Taillefeuille-X.Taillegaine
            X.Cutstatus='partiellementcoupee'
        produce Feuille(X, X_apex)
    
    ### Recalcul de la biomasse foliaire ###
    elif TPS==ParamP[X.id_plante]['DCOUP']+0.75:
      if X.Taillegaine*1.15>Seuil[X.id_plante][X.id_talle]:
        Seuil[X.id_plante][X.id_talle]=X.Taillegaine
      
      Taille_finale_gaine[X.id_plante][X.id_talle][X.id_rang]=X.Taillegaine
      
      if X.id_rang==1 and X.id_talle>0:
        vtx_feuille=[x for x in les_feuilles if (mtg.property('ParamFeuille').get(x).id_plante==X.id_plante and mtg.property('ParamFeuille').get(x).id_talle==X.id_talle and mtg.property('ParamFeuille').get(x).id_rang==X.id_rang)][0]
        phyto=Complex(vtx_feuille)
        phyto_precedent=Father(phyto)
        feuille_ref=[x for x in Components(phyto_precedent) if Class(x)=='F'][0]
        Seuil[X.id_plante][X.id_talle]=max(Seuil[X.id_plante][X.id_talle],mtg.property('ParamFeuille').get(feuille_ref).Taillegaine)
      X.biomass=BiomassFeuille(X.Taillefeuille,X.coupe,X.geno)
    else:
      produce Feuille(X, X_apex)


GetPos(a,b,c):
  for ID in xrange(nb_plantes):
    if TPS==ParamP[ID]['DCOUP']+0.5:
      produce


SegFeuille(X):
  if TPS==ParamP[X.id_plante]['DCOUP']+0.75:
    produce


Entrenoeud(X_EN, X_AP, X_F):
  if (X_AP.phenological_state == 'reproductive' and X_F.Phase <> 'mature'):
    X_EN.internode_type = 'long_internode'
  if (X_F.Phase == 'mature' and X_EN.internode_type == 'long_internode' and X_EN.length < X_F.Taillefinalegaine + 5):              # condition pour arreter la croissance des entrenoeuds
    X_EN.length += 0.5
    produce Entrenoeud(X_EN, X_AP, X_F)
  elif (X_F.Phase == 'mature' and X_EN.internode_type == 'long_internode' and X_EN.length >= X_F.Taillefinalegaine + 5):
    produce Entrenoeud(X_EN, X_AP, X_F)


apex(X):
  global les_feuilles, current_day, meteo
  if option_floraison == True:
  # Mise a jour des parametres d induction a chaque changement de journee
    if X.day < current_day:
      X.day = current_day
      daily_temperature = meteo.mean_temperature[meteo.id_day == current_day].iloc[0]
      daily_daylength = meteo.daylength[meteo.id_day == current_day].iloc[0]
      
      if X.phenological_state == 'vegetative':
        print flowering_model
        X.primary_induction_index += flowering_model.vernalisation_function(daily_temperature)
        X.primary_induction_index = min(X.primary_induction_index, 1)
        X.potential_leaf_number = flowering_model.potential_leaf_number_calculation(X.primary_induction_index)
        if flowering_model.test_vernalisation(X.primary_induction_index, X.potential_leaf_number, X.primordia_number):
          X.phenological_state = 'vernalized'
          X.approx_final_leaf_number = flowering_model.approx_final_leaf_number_calculation(daily_daylength, X.potential_leaf_number)
          output_batch_dict['vernalisation_CDD'] = TPS
      
      elif X.phenological_state == 'vernalized':
        X.approx_final_leaf_number = flowering_model.approx_final_leaf_number_calculation(daylength = daily_daylength, potential_leaf_number = X.potential_leaf_number)
        if 0.5 * X.approx_final_leaf_number <= X.total_emerged_leaf:
          X.final_leaf_number = X.approx_final_leaf_number
          X.phenological_state = 'reproductive'
          
          output_batch_dict['final_leaf_number'] = X.final_leaf_number
          output_batch_dict['floral_transition_CDD'] = TPS
  
  
  if groupe=='croissance':
    if (X.phenological_state == 'reproductive' and X.total_created_leaves >= X.final_leaf_number):
      YEPI = ParamEpi(id_plante = X.id_plante, id_talle = X.id_talle, id_rang = X.id_rang, nb_epillets = X.spikelet_primordia_number)
      #produce Epi(YEPI)
      for i in xrange(X.nb_epillets):              # xrange a remplacer par range en python 3
        YEntrenoeudEpi = ParamEntrenoeudEpi(id_plante = X.id_plante, id_talle = X.id_talle, id_rang = X.id_rang + i, long_entrenoeud = 0)      # ATTENTION il faudra donner une orientation au premier epillet
        YEpillet = ParamEpillet(id_plante = X.id_plante, id_talle = X.id_talle, id_rang = X.id_rang + i, long_epillet = 0)
        nproduce RollR(180) EntrenoeudEpi(YEntrenoeudEpi) SB +(20) Epillet(YEpillet) EB
        output_batch_dict['spike_creation_CDD'] = TPS
    else:
      vtx_feuille=[x for x in les_feuilles if (mtg.property('ParamFeuille').get(x).id_plante==X.id_plante and mtg.property('ParamFeuille').get(x).id_talle==X.id_talle and mtg.property('ParamFeuille').get(x).id_rang==X.id_rang)][0]
      if X.retard==2:
        #Seuil[X.id_plante][X.id_talle]=Seuil[X.id_plante][X.id_talle] * 1.15
        Taille_finale_gaine[X.id_plante][X.id_talle].append(5.5)
        YP=ParamPhytomere(X.id_plante,X.id_talle,X.id_rang+1)
        YF=ParamFeuille(age=0,Agecroiss=0,Taillefeuille=0,id_plante=X.id_plante,id_talle=X.id_talle,id_rang=X.id_rang+1,Ymax=Premiecroiss[X.id_plante],Taillefinalelimbe=0.8*Premiecroiss[X.id_plante],Taillefinalegaine=0.2*Premiecroiss[X.id_plante])
        Yb=ParambourgeonRoot(X.id_plante,X.id_talle,X.id_rang+1)
        YAT=ParamApexTal(X.id_plante,X.id_talle,X.id_rang+1)
        YINT=ParamEntrenoeud(X.id_plante, X.id_talle, X.id_rang+1)      # AJOUT SIMON
        X.id_rang += 1
        X.retard = 0
        X.primordia_number = 2 * X.total_emerged_leaf + 4               # ICI
        X.total_created_leaves += 1
        produce RollR(180) phytomere(YP, X) bourgeonRoot(Yb, YINT) ApexTal(YAT) Entrenoeud(YINT, X, YF) FLW SB Feuille(YF, X) FLW EB apex(X)
      elif X.retard==1:
        X.retard=2
        print 'RETARD_1'
        produce apex(X)
      elif abs(Seuil[X.id_plante][X.id_talle]-mtg.property('ParamFeuille').get(vtx_feuille).Taillefeuille)<2: #Si |Seuil-Taillefeuille| <2mm
        X.retard=1
        print 'RETARD_0'
        produce apex(X)
  if groupe=='defoliation':
    produce apex(X)


ApexTal(X):
  global les_feuilles,Surfoliairetotale,alea1,alea1_index,alea2
  if option_tallage == True:
    if groupe=='croissance':
      vtx_feuille_ref=[x for x in les_feuilles if (mtg.property('ParamFeuille').get(x).id_plante==X.id_plante and mtg.property('ParamFeuille').get(x).id_talle==X.id_talle and mtg.property('ParamFeuille').get(x).id_rang==X.id_rang+2)]
      #if vtx_feuille_suivante!=[]:  # la feuille du rang+2 existe donc la feuille du rang+1 emerge
      if vtx_feuille_ref!=[]:
        seuil=max(Taille_finale_gaine[X.id_plante][X.id_talle][X.id_rang-1],5.5)
        
        if X.id_rang==0 and X.id_talle==0:
          produce F(0)
        
        Sitefillingproba=10000 #Le temps de faire les tests sur un faible nombre d'iterations (400)
        #Sitefillingproba=alea1[alea1_index[X.id_plante]]*ParamP[X.id_plante]['STOPTALLAGE'] #Besoin de choisir des valeurs de tallage a laquelle arreter
        alea1_index[X.id_plante]+=1
        rapportS9_SSol=FonctionParamPlante.rapportS9_SSol(X.id_plante)
        #print "Plante",X.id_plante, "   rapportS9_SSol",rapportS9_SSol,"SENSETALLAGE",ParamP[X.id_plante]['SENSETALLAGE'],"Sitefillingproba", Sitefillingproba
        
        if (rapportS9_SSol<Sitefillingproba): #Pour la gestoin du site filling : plus la surface augmente et plus la probabilite de faire un talle diminue
          if (rapportS9_SSol<=ParamP[X.id_plante]['SENSETALLAGE']):
            nb_talle[X.id_plante]=nb_talle[X.id_plante]+1
            Seuil[X.id_plante].append(seuil)
            Taille_finale_gaine[X.id_plante].append([5.5,5.5])
            YP=ParamPhytomere(X.id_plante,nb_talle[X.id_plante],id_rang=0)
            YF=ParamFeuille(age=0,Agecroiss=0,Taillefeuille=0,id_plante=X.id_plante,id_talle=nb_talle[X.id_plante],id_rang=1,Ymax=Premiecroiss[X.id_plante],Taillefinalelimbe=0.8*Premiecroiss[X.id_plante],Taillefinalegaine=0.2*Premiecroiss[X.id_plante])
            Yb=ParambourgeonRoot(X.id_plante,nb_talle[X.id_plante],id_rang=1)
            YAT=ParamApexTal(X.id_plante,nb_talle[X.id_plante],id_rang=1)
            YA=ParamApex(X.id_plante,nb_talle[X.id_plante],id_rang=1)
            YINT=ParamEntrenoeud(X.id_plante,id_talle=0,id_rang=1)      # AJOUT SIMON
            produce SB phytomere(YP, YA) RollR(95) GetHead(0, 0, 0) bourgeonRoot(Yb, YINT) ApexTal(YAT) Entrenoeud(YINT, YA, YF) FLW SB Feuille(YF, YA) FLW EB apex(YA) EB
          
          if (rapportS9_SSol>ParamP[X.id_plante]['SENSETALLAGE']):
            deuxiemede=alea2[alea1_index[X.id_plante]-1]*5
            if (deuxiemede>=2):
              nb_talle[X.id_plante]=nb_talle[X.id_plante]+1
              Seuil[X.id_plante].append(seuil)
              Taille_finale_gaine[X.id_plante].append([5.5,5.5])
              YP=ParamPhytomere(X.id_plante,nb_talle[X.id_plante],id_rang=0)
              YF=ParamFeuille(age=0,Agecroiss=0,Taillefeuille=0,id_plante=X.id_plante,id_talle=nb_talle[X.id_plante],id_rang=1,Ymax=Premiecroiss[X.id_plante],Taillefinalelimbe=0.8*Premiecroiss[X.id_plante],Taillefinalegaine=0.2*Premiecroiss[X.id_plante])
              Yb=ParambourgeonRoot(X.id_plante,nb_talle[X.id_plante],id_rang=1)
              YAT=ParamApexTal(X.id_plante,nb_talle[X.id_plante],id_rang=1)
              YA=ParamApex(X.id_plante,nb_talle[X.id_plante],id_rang=1)
              YINT=ParamEntrenoeud(X.id_plante,id_talle=0,id_rang=1)      # AJOUT SIMON
              produce SB phytomere(YP, YA) RollR(95) GetHead(0, 0, 0) bourgeonRoot(Yb, YINT) ApexTal(YAT) Entrenoeud(YINT, YA, YF) FLW SB Feuille(YF, YA) FLW EB apex(YA) EB
            else:
              produce
        else:
          produce
      else:
        produce ApexTal(X)
    if groupe=='defoliation':
      produce ApexTal(X)
  
  else:
    produce ApexTal(X)


Epi(X):
  for i in xrange(X.nb_epillets):              # xrange a remplacer par range en python 3
    YEntrenoeudEpi = ParamEntrenoeudEpi(id_plante = X.id_plante, id_talle = X.id_talle, id_rang = X.id_rang + i, long_entrenoeud = 0)      # ATTENTION il faudra donner une orientation au premier epillet
    YEpillet = ParamEpillet(id_plante = X.id_plante, id_talle = X.id_talle, id_rang = X.id_rang + i, long_epillet = 0)
    nproduce RollR(180) EntrenoeudEpi(YEntrenoeudEpi) SB +(20) Epillet(YEpillet) EB


EntrenoeudEpi(X):                      # Compter les entrenoeuds de l epi et appliquer une regle de croissance differente pour le pedoncule
  if X.long_entrenoeud < 15:            # PARAMETRE
     X.long_entrenoeud += 0.3            # PARAMETRE
  produce EntrenoeudEpi(X)


Epillet(X):
  if X.long_epillet < 5:                 # PARAMETRE
    X.long_epillet += 0.2                # PARAMETRE
  produce Epillet(X)


racine(X):
  global les_racines,les_feuilles
  if OptionRacine=='SansRacines':
    produce *
  else:
    if X.axe_arret==0:
      feuille_test=[x for x in les_feuilles if (mtg.property('ParamFeuille').get(x).id_plante==X.id_plante and mtg.property('ParamFeuille').get(x).id_talle==X.id_talle and mtg.property('ParamFeuille').get(x).id_rang==X.feuil_ref+6)]
      if feuille_test!=[] and mtg.property('ParamFeuille').get(feuille_test[0]).Phase!='cachee' :
        X.axe_arret=1
    
    elif X.lateral_arret==0:
      feuille_test=[x for x in les_feuilles if (mtg.property('ParamFeuille').get(x).id_plante==X.id_plante and mtg.property('ParamFeuille').get(x).id_talle==X.id_talle and mtg.property('ParamFeuille').get(x).id_rang==X.feuil_ref+7)]
      if feuille_test!=[] and mtg.property('ParamFeuille').get(feuille_test[0]).Phase!='cachee':
        X.lateral_arret=1


bourgeonRoot(X, Y_EN):
  global num_pointe,les_feuilles,Biomasse_aerienne,groupe 
  
  if OptionRacine=='SansRacines':
    produce *
  
  else:
    if Y_EN.length > 0:
      produce *
  
    else:
      if groupe=='croissance':
        feuille_du_phytomere=[x for x in les_feuilles if (mtg.property('ParamFeuille').get(x).id_plante==X.id_plante and mtg.property('ParamFeuille').get(x).id_talle==X.id_talle and mtg.property('ParamFeuille').get(x).id_rang==X.id_rang)][0]
        ordre=Order(Complex(feuille_du_phytomere)) #ordre de la talle
        
        #if ordre<=1:
        if X.nb_prod_root==0:
          feuille_reference=[x for x in les_feuilles if (mtg.property('ParamFeuille').get(x).id_plante==X.id_plante and mtg.property('ParamFeuille').get(x).id_talle==X.id_talle and mtg.property('ParamFeuille').get(x).id_rang==X.id_rang+ordre)]
          if feuille_reference!=[] and mtg.property('ParamFeuille').get(feuille_reference[0]).Phase!='cachee':
            num_pointe=num_pointe+1
            #if Biomasse_aerienne<0.1:
            #  if les_diametres==[]:
            #    Diameter=ParamP[X.id_plante]['P_diamMax']	#random.normalvariate(0.59,0.11)       #(2.3*Biomasse_aerienne+0.33)
            #  else:
            #    nb=len(les_diametres)+1  
            #    Diameter=P_diamMax	#random.normalvariate(0.59,0.11)         #nb*(2.3*Biomasse_aerienne+0.33-(sum(les_diametres)/nb))
            #else:
            #  nb=len(les_diametres)+1
            #  Diameter=P_diamMax		#random.normalvariate(0.59,0.11)             #nb*(0.56-(sum(les_diametres)/nb))
            
            if Biomasse_aerienne[X.id_plante]<paramManagement['SBDmax']:
              Diameter=paramManagement['Dmax']*(1+((paramManagement['SBDmax']-Biomasse_aerienne[X.id_plante])/paramManagement['SBDmax']))*((Biomasse_aerienne[X.id_plante]+paramManagement['SBDmax'])/(2*paramManagement['SBDmax']))**2
            else:
              Diameter=paramManagement['Dmax']
            
            les_diametres.append(Diameter)
            X.nb_prod_root=1
            Y=pte(id_pointe=num_pointe,id_plante=X.id_plante,age=0,diametre=Diameter,Tortue=np.array([[0.,0.,-1],[0.,1,0],[-1.,0.,0.]]),isaxe=True)
            Y2=ParamRacine(age=0,id_plante=X.id_plante,id_talle=X.id_talle,id_rang=X.id_rang,feuil_ref=X.id_rang+ordre)
            produce bourgeonRoot(X) FLW SB() racine(Y2) SetHead(0.,0.,-1.,-1.,0.,0.) tip(Y) FLW EB()
          else:
            produce bourgeonRoot(X, Y_EN)
        
        elif X.nb_prod_root==1:
          if ordre==0:
            feuille_reference=[x for x in les_feuilles if (mtg.property('ParamFeuille').get(x).id_plante==X.id_plante and mtg.property('ParamFeuille').get(x).id_talle==X.id_talle and mtg.property('ParamFeuille').get(x).id_rang==X.id_rang+1)]
          else:
            feuille_reference=[x for x in les_feuilles if (mtg.property('ParamFeuille').get(x).id_plante==X.id_plante and mtg.property('ParamFeuille').get(x).id_talle==X.id_talle and mtg.property('ParamFeuille').get(x).id_rang==X.id_rang+ordre+1)]
          if feuille_reference!=[] and mtg.property('ParamFeuille').get(feuille_reference[0]).Phase!='cachee':
            num_pointe=num_pointe+1
            #if Biomasse_aerienne<0.1:
            #  if les_diametres==[]:
            #    Diameter=P_diamMax#random.normalvariate(0.59,0.11)          #(2.3*Biomasse_aerienne+0.33)
            #  else:
            #      nb=len(les_diametres)+1  
            #    Diameter=P_diamMax#random.normalvariate(0.59,0.11)            #nb*(2.3*Biomasse_aerienne+0.33-(sum(les_diametres)/nb))
            #else:
            #  nb=len(les_diametres)+1
            #  Diameter=P_diamMax#random.normalvariate(0.59,0.11)             #nb*(0.56-(sum(les_diametres)/nb))
            
            if Biomasse_aerienne[X.id_plante]<paramManagement['SBDmax']:
              Diameter=paramManagement['Dmax']*(1+((paramManagement['SBDmax']-Biomasse_aerienne[X.id_plante])/paramManagement['SBDmax']))*((Biomasse_aerienne[X.id_plante]+paramManagement['SBDmax'])/(2*paramManagement['SBDmax']))**2
            else:
              Diameter=paramManagement['Dmax']
            #Diameter=0.58
            
            les_diametres.append(Diameter)
            X.nb_prod_root=2
            Y=pte(id_pointe=num_pointe,id_plante=X.id_plante,age=0,diametre=Diameter,Tortue=np.array([[0.,0.,-1],[0.,1,0],[-1.,0.,0.]]),isaxe=True)
            Y2=ParamRacine(age=0,id_plante=X.id_plante,id_talle=X.id_talle,id_rang=X.id_rang,feuil_ref=X.id_rang+ordre+1)
            produce FLW SB() racine(Y2)  SetHead(0.,0.,-1.,-1.,0.,0.) tip(Y) FLW EB()
          else:
            produce bourgeonRoot(X, Y_EN)
        
        #else:
        #  if X.nb_prod_root==0:
        #    feuille_reference=[x for x in les_feuilles if (mtg.property('ParamFeuille').get(x).id_plante==X.id_plante and mtg.property('ParamFeuille').get(x).id_talle==X.id_talle and mtg.property('ParamFeuille').get(x).id_rang==X.id_rang+(ordre-1))]
        #    if feuille_reference!=[] and mtg.property('ParamFeuille').get(feuille_reference[0]).Phase!='cachee':
        #      num_pointe=num_pointe+1
        #      #if Biomasse_aerienne<0.1:
        #      #  if les_diametres==[]:
        #      #    Diameter=P_diamMax#random.normalvariate(0.59,0.11)          #(2.3*Biomasse_aerienne+0.33)
        #      #  else:
        #      #    nb=len(les_diametres)+1  
        #      #    Diameter=P_diamMax#random.normalvariate(0.59,0.11)           #nb*(2.3*Biomasse_aerienne+0.33-(sum(les_diametres)/nb))
        #      #else:
        #      #  nb=len(les_diametres)+1
        #      #  Diameter=P_diamMax#random.normalvariate(0.59,0.11)            #nb*(0.56-(sum(les_diametres)/nb))
        #      
        #      if Biomasse_aerienne[X.id_plante]<paramManagement['SBDmax']:
        #        Diameter=paramManagement['Dmax']*(1+((paramManagement['SBDmax']-Biomasse_aerienne[X.id_plante])/paramManagement['SBDmax']))*((Biomasse_aerienne[X.id_plante]+paramManagement['SBDmax'])/(2*paramManagement['SBDmax']))**2
        #      else:
        #        Diameter=paramManagement['Dmax']
        #      
        #      les_diametres.append(Diameter)
        #      X.nb_prod_root=1
        #      Y=pte(id_pointe=num_pointe,id_plante=X.id_plante,age=0,diametre=Diameter,Tortue=np.array([[0.,0.,-1],[0.,1,0],[-1.,0.,0.]]))
        #      Y2=ParamRacine(age=0,id_plante=X.id_plante,id_talle=X.id_talle,id_rang=X.id_rang)
        #      produce bourgeonRoot(X) FLW SB() racine(Y2)  SetHead(0.,0.,-1.,-1.,0.,0.) tip(Y)  FLW EB()
        #    else:
        #      produce bourgeonRoot(X)
        #      
        #  elif X.nb_prod_root==1:
        #    feuille_reference=[x for x in les_feuilles if (mtg.property('ParamFeuille').get(x).id_plante==X.id_plante and mtg.property('ParamFeuille').get(x).id_talle==X.id_talle and mtg.property('ParamFeuille').get(x).id_rang==X.id_rang+ordre)]
        #    if feuille_reference!=[] and mtg.property('ParamFeuille').get(feuille_reference[0]).Phase!='cachee':
        #      num_pointe=num_pointe+1
        #      #if Biomasse_aerienne<0.1:
        #      #  if les_diametres==[]:
        #      #    Diameter=P_diamMax#random.normalvariate(0.59,0.11)          #(2.3*Biomasse_aerienne+0.33)
        #      #  else:
        #      #    nb=len(les_diametres)+1  
        #      #    Diameter=P_diamMax#random.normalvariate(0.59,0.11)            #nb*(2.3*Biomasse_aerienne+0.33-(sum(les_diametres)/nb))
        #      #else:
        #      #  nb=len(les_diametres)+1
        #      #  Diameter=P_diamMax#random.normalvariate(0.59,0.11)             #nb*(0.56-(sum(les_diametres)/nb))
        #      
        #      if Biomasse_aerienne[X.id_plante]<paramManagement['SBDmax']:
        #        Diameter=paramManagement['Dmax']*(1+((paramManagement['SBDmax']-Biomasse_aerienne[X.id_plante])/paramManagement['SBDmax']))*((Biomasse_aerienne[X.id_plante]+paramManagement['SBDmax'])/(2*paramManagement['SBDmax']))**2
        #      else:
        #        Diameter=paramManagement['Dmax']
        #      
        #      
        #      les_diametres.append(Diameter)
        #      X.nb_prod_root=2
        #      Y=pte(id_pointe=num_pointe,id_plante=X.id_plante,age=0,diametre=Diameter,Tortue=np.array([[0.,0.,-1],[0.,1,0],[-1.,0.,0.]]))
        #      Y2=ParamRacine(age=0,id_plante=X.id_plante,id_talle=X.id_talle,id_rang=X.id_rang)
        #      produce FLW SB() racine(Y2)  SetHead(0.,0.,-1.,-1.,0.,0.) tip(Y) FLW EB()
        #    else:
        #      produce bourgeonRoot(X)
        
        if X.nb_prod_root==2:
          produce
        
        #if ordre<=1:
        #  feuille_reference=feuille_du_phytomere
        #  if mtg.property('ParamFeuille').get(feuille_reference).Phase!='cachee':
        #    num_pointe=num_pointe+1
        #    if Biomasse_aerienne<0.1:
        #      if les_diametres==[]:
        #        Diameter=P_diamMax       #(2.3*Biomasse_aerienne+0.33)
        #      else:
        #        nb=len(les_diametres)+1
        #        Diameter=P_diamMax         #nb*(2.3*Biomasse_aerienne+0.33-(sum(les_diametres)/nb))
        #    else:
        #      nb=len(les_diametres)+1
        #      Diameter=P_diamMax          #nb*(0.56-(sum(les_diametres)/nb))
        #    les_diametres.append(Diameter)
        #    Y=pte(id_pointe=num_pointe,age=0,diametre=Diameter,Tortue=np.array([[0.,0.,-1],[0.,1,0],[-1.,0.,0.]]))
        #    Y2=ParamRacine(age=0,id_plante=X.id_plante,id_talle=X.id_talle,id_rang=X.id_rang)
        #    produce FLW SB() racine(Y2) IN SB() SetHead(0.,0.,-1.,-1.,0.,0.) tip(Y) IN EB() FLW EB()
        #  else:
        #    produce bourgeonRoot(X)
        #else:
        #  feuille_reference=[x for x in les_feuilles if (mtg.property('ParamFeuille').get(x).id_plante==X.id_plante and mtg.property('ParamFeuille').get(x).id_talle==X.id_talle and mtg.property('ParamFeuille').get(x).id_rang==X.id_rang+(ordre-1))]
        #  if feuille_reference!=[] and mtg.property('ParamFeuille').get(feuille_reference[0]).Phase!='cachee':
        #    num_pointe=num_pointe+1
        #    
        #    if Biomasse_aerienne<0.1:
        #      nb=len(les_diametres)+1
        #      Diameter=P_diamMax   #nb*(2.3*Biomasse_aerienne+0.33-(sum(les_diametres)/nb))#*0.9  
        #    else:
        #      nb=len(les_diametres)+1
        #      Diameter=P_diamMax   #nb*(0.56-(sum(les_diametres)/nb))#*0.9  
        #    les_diametres.append(Diameter)
        #    Y=pte(id_pointe=num_pointe,age=0,diametre=Diameter,Tortue=np.array([[0.,0.,-1],[0.,1,0],[-1.,0.,0.]]))
        #    Y2=ParamRacine(age=0,id_plante=X.id_plante,id_talle=X.id_talle,id_rang=X.id_rang)
        #    produce FLW SB() racine(Y2) IN SB() SetHead(0.,0.,-1.,-1.,0.,0.) tip(Y) IN EB() FLW EB()
        #  else:
        #    produce bourgeonRoot(X)
        #  produce bourgeonRoot(X)
      
      if groupe=='defoliation':
        produce bourgeonRoot(X, Y_EN)


tip(X):
  global mtg,num_primordium,les_pointes,RootPotentialNewBiomass,PourcentageRootGrowthRealized,groupe,TPS_expe
  if OptionRacine=='SansRacines':
      produce *
  else:
    if groupe=='croissance' and not X.arretee:
      X.age=X.age+dt
      for x in les_pointes:
        if x[0]==X.id_pointe:
          vertex_pointe=x[1]
          break
      
      vertex_racine=Complex(vertex_pointe)
      if X.isaxe and mtg.property('ParamRacine').get(vertex_racine).axe_arret==1:
        X.arretee=True
      elif not X.isaxe and mtg.property('ParamRacine').get(vertex_racine).lateral_arret==1:
        X.arretee=True
      
      #plante=Complex(vertex_pointe,2)
      pourcentage=PourcentageRootGrowthRealized[X.id_plante]
      
      if X.arretee==False and X.senile==False and X.diametre>ParamP[X.id_plante]['P_diamMin']:
        profondeur=X.posO[2]
        PotentielCroissance=CroissanceRacine2(X,profondeur)
        RootPotentialNewBiomass[X.id_plante]+=ParamP[X.id_plante]['P_RootMasseVolumique']*(pi*(X.diametre/2)*(X.diametre/2)*PotentielCroissance)
        elongation=PotentielCroissance*pourcentage
        X.longueur=X.longueur+elongation
        distInterRamif=ParamP[X.id_plante]['P_distRamif'] * float(Sol[Couche(X.id_plante,profondeur)][1])
        init=1
        
        while X.longueur > distInterRamif:
          (X.Tortue,X.posO)=Gravitropisme(X.id_plante,vertex_pointe,X.segment,profondeur,ParamP[X.id_plante]['longSegNorm'],init)
          if X.segment==0:
            X.segment=1
          
          Z=seg(TPS,X.diametre,distInterRamif,X.id_pointe)
          nproduce SetHead(X.Tortue[0][0],X.Tortue[1][0],X.Tortue[2][0],X.Tortue[0][2],X.Tortue[1][2],X.Tortue[2][2])segment(Z)
          
          diam=tireDiamPointeFille(X.id_plante,X.diametre)
          num_primordium=num_primordium+1
          param=primord(id_plante=X.id_plante, id_primord=num_primordium,age=0,diametre=diam,Tortue=X.Tortue,id_pointe_axe=X.id_pointe,posO=X.posO)
          nproduce Site(param)
          
          X.longueur=X.longueur-distInterRamif
          init=0
      
      #vertex_axe=Axis(vertex_pointe)
      #if X.senile==False and TPS>10 and X.arretee==False:
      #  racine=Complex(vertex_pointe)
      #  elements=Components(racine)
      #  if elements[len(elements)-1]==vertex_pointe: #Pointe d'un axe
      #    phyto=Complex(racine)
      #    ordre=Order(phyto)
      #    feuille_associe=[x for x in Components(phyto) if Class(x)=='F'][0]
      #    if ordre==0:
      #      comp=0
      #    else:
      #      comp=ordre-1
      #    #feuille_reference=[x for x in les_feuilles if (mtg.property('ParamFeuille').get(x).id_plante==mtg.property('ParamFeuille').get(feuille_associe).id_plante and mtg.property('ParamFeuille') .get(x).id_talle==mtg.property('ParamFeuille').get(feuille_associe).id_talle and mtg.property('ParamFeuille').get(x).id_rang==mtg.property('ParamFeuille').get(feuille_associe).id_rang+comp+4)]
      #    #if feuille_reference!=[] and mtg.property('ParamFeuille').get(feuille_reference[0]).Phase=='visible':
      #    #  X.arretee=True
      # 
      #  #else: # Pointe d'une racine laterale
      #  #  if X.age > (ParamP[X.id_plante]['P_penteDureeVieDiamTMD']*X.diametre*ParamP[X.id_plante]['P_TMD']):
      #  #    X.arretee=True
      #  
      #  #if X.senile==False and TPS>10 and :
      #  #  X.senile=True    #La pointe devient senile
      #  
      #  #if X.senile==True:  #Teste si tout l'axe est mort
      #  #  base_axe=vertex_axe[0]
      #  #  les_pointes_axe=Extremities(base_axe)
      #  #  X.axe_mort=True
      #  #  for x in les_pointes_axe:
      #  #    if mtg.property('pte').get(x).senile==False:
      #  #      X.axe_mort=False
      #  
      #for i in TPS_expe:
      #  if TPS==i-2:
      #    nproduce GetPos(0,0,0)
      nproduce tip(X)
      produce
    
    else:
      for i in TPS_expe:
        if TPS==i-2:
          nproduce GetPos(0,0,0)
      produce tip(X)


Site(X):
  global mtg,num_pointe,les_pointes,groupe
  if OptionRacine=='SansRacines':
    produce *
  else:
    if groupe=='croissance':
      if X.diametre < ParamP[X.id_plante]['P_diamMin']:
        produce 
      elif X.age < ParamP[X.id_plante]['P_ageMaturitePointe']:
        X.age=X.age+dt
      else:
        num_pointe=num_pointe+1
        Y=pte(id_pointe=num_pointe,age=0,Tortue=X.Tortue,diametre=X.diametre,posO=X.posO)
        produce SB() tip(Y) EB()
    if groupe=='defoliation':
      produce Site(X)

#segment(X):
#  global les_pointes,Rootbiom
#  vertex_pointe=0
#  Rootbiom=Rootbiom+P_RootMasseVolumique*(pi*(X.diametre/2)*(X.diametre/2)*X.longueur)
#  
#  for x in les_pointes:
#    if mtg.property('pte').get(x).id_pointe==X.id_pointe_axe:
#      vertex_pointe=x
#      break
#  if mtg.property('pte').get(vertex_pointe).axe_mort:
#    nproduce
#  else:
#    nproduce segment(X)
#  produce




interpretation:


phytomere(X, Y):
  produce Right(X.angletal)


Entrenoeud(X, Y, Z):
  produce SetWidth(1)SetColor(3)F(X.length)


Feuille(X, Y):
  global Surfoliairetotale,Surfoliaireencours,les_feuilles
  if groupe=='croissance':
    surfacefeuille=0
    Torsiongaine=ParamP[X.id_plante]['Torsiongaine']
    curve=ParamP[X.id_plante]['curve']*LSTEP
    Taillepointelineraire=ParamP[X.id_plante]['Taillepointelineraire']
    
    if (X.Phase=='cachee'):
      numsteps=(X.Taillefeuille-X.coupe)/LSTEP
      for i in xrange(int(numsteps)):
        taille=X.Taillefeuille
        L0=X.Taillefinalelimbe-taille
        
        if (i<((taille-Taillepointelineraire)/LSTEP)):
          large=(paramManagement['CoefSecondDegreLonLar']*pow(((L0+(i*LSTEP))/X.Taillefinalelimbe), 2)+paramManagement['CoefPremierDegreLonLar']*((L0+(i*LSTEP))/X.Taillefinalelimbe)+paramManagement['ConstantLonLar'])*(((paramManagement['CoefDirLonLarAjust']*log(X.Ymax))-paramManagement['OrdOriLonLarAjust'])/2)
        else:
          largini=(paramManagement['CoefSecondDegreLonLar']*pow(((L0+((i-1)*LSTEP))/X.Taillefinalelimbe), 2)+paramManagement['CoefPremierDegreLonLar']*((L0+((i-1)*LSTEP))/X.Taillefinalelimbe)+paramManagement['ConstantLonLar'])*(((paramManagement['CoefDirLonLarAjust']*log(X.Ymax))-paramManagement['OrdOriLonLarAjust'])/2)
          large=largini-((i-((taille-Taillepointelineraire)/LSTEP))*((largini*LSTEP)/Taillepointelineraire))
        
        if(i<(10/LSTEP)):
          rank=X.id_rang
          if large<=0:
            large=0.01
          nproduce  StartGC() SetContour(limbo) SetWidth(large)SetColor(2)Down(Torsiongaine*pow(-1,rank))F(LSTEP)EndGC()
        
        if(i>(10/LSTEP)):
          if large<=0:
            large=0.01
          nproduce StartGC() SetContour(limbo)SetWidth(large)SetColor(2)F(LSTEP)EndGC()
      produce
    
    if (X.Phase!='cachee'):
      vtx_feuille=[x for x in les_feuilles if (mtg.property('ParamFeuille').get(x).id_plante==X.id_plante and mtg.property('ParamFeuille').get(x).id_talle==X.id_talle and mtg.property('ParamFeuille').get(x).id_rang==X.id_rang)][0]  # vertex de la feuille
      nproduce Left(X.angletal)
      
      if X.Cutstatus!='entierementcoupee':
        numsteps=ceil((X.Taillefeuille)/LSTEP)
      else:
        numsteps=ceil((X.Taillegaine)/LSTEP)
      numstepsg=ceil((X.Taillegaine)/LSTEP)
      
      for i in xrange(int(numsteps)):
        if (i<numstepsg-1):
          rank=X.id_rang
          large=max((2/pi)*(paramManagement['CoefDirLonLarAjust']*log(max(X.Taillegaine*5,1))-paramManagement['OrdOriLonLarAjust']),0.1)
          if(i<(10/LSTEP)):
            if(i==1):
              if large<=0:
                large=0.01
              nproduce SetWidth(large)SetContour(gaino)StartGC()SetColor(2)Down(Torsiongaine*pow(-1,rank))F(LSTEP)EndGC()
            else:
              if large<=0:
                large=0.01
              nproduce SetWidth(large)SetContour(gaino)StartGC()SetColor(2)Down(Torsiongaine*pow(-1,rank))F(LSTEP)EndGC() 
          
          else:
            if large<=0:
              large=0.01
            nproduce SetWidth(large)SetContour(gaino)StartGC()SetColor(2)F(LSTEP)EndGC()
        
        else:
          taille=X.Taillelimbe+X.coupe
          L0=X.Taillefinalelimbe-taille
          if ((i-numstepsg)<((taille-Taillepointelineraire)/LSTEP)):
            large=(paramManagement['CoefSecondDegreLonLar']*pow(((L0+((i-numstepsg)*LSTEP))/X.Taillefinalelimbe), 2)+paramManagement['CoefPremierDegreLonLar']*((L0+((i-numstepsg)*LSTEP))/X.Taillefinalelimbe)+paramManagement['ConstantLonLar'])*(((paramManagement['CoefDirLonLarAjust']*log(X.Ymax))-paramManagement['OrdOriLonLarAjust'])/2)
          else:
            a=pow(((L0+(((i-numstepsg)-1)*LSTEP))/X.Taillefinalelimbe), 2)
            b=log(X.Ymax)
            largini=(paramManagement['CoefSecondDegreLonLar']*pow(((L0+(((i-numstepsg)-1)*LSTEP))/X.Taillefinalelimbe), 2)+paramManagement['CoefPremierDegreLonLar']*((L0+(((i-numstepsg)-1)*LSTEP))/X.Taillefinalelimbe)+paramManagement['ConstantLonLar'])*(((paramManagement['CoefDirLonLarAjust']*log(X.Ymax))-paramManagement['OrdOriLonLarAjust'])/2)
            large=largini-(((i-numstepsg)-((taille-Taillepointelineraire)/LSTEP))*((largini*LSTEP)/Taillepointelineraire))
          
          if(i<numstepsg-1):
            large=0.
          
          surfacefeuille=surfacefeuille+large*2.*LSTEP
          #Surfoliaireencours=Surfoliaireencours+large*2.*LSTEP
          Agesenesc=paramManagement['T0sen']+(X.Ymax/20)*paramManagement['Lpot']
          
          if(i==numstepsg):
            if X.id_rang>4:
              pseudotige=max([Taille_finale_gaine[X.id_plante][X.id_talle][x] for x in xrange(X.id_rang-3,X.id_rang-1)])
            else:
              pseudotige=Taille_finale_gaine[X.id_plante][X.id_talle][X.id_rang-1]
            
            if ( X.Taillegaine > pseudotige):
              nproduce StartGC() SetContour(limbo)Left(X.angleinsert)SetColor(2)F(LSTEP)EndGC()
          
          if (X.age<=Agesenesc):
            if ((i>numsteps-2) and X.coupe>2): # Pour avoir cicatrice au bout feuille coupees
              if i<numstepsg:
                if X.Cutstatus=='entierementcoupee':
                  large_temp=max((2/pi)*(paramManagement['CoefDirLonLarAjust']*log(max(X.Taillegaine*5,1))-paramManagement['OrdOriLonLarAjust']),0.1)
                  if large_temp<=0:
                    large_temp=0.01
                  nproduce SetWidth(large_temp)SetContour(gaino)StartGC()SetColor(2)F(LSTEP)EndGC()
                else:
                  if large<=0:
                    large=0.01
                  nproduce StartGC() SetContour(limbo) SetWidth(large)RollR(0)Left(curve)SetColor(2)F(LSTEP)EndGC()
              
              else:
                if large<=0:
                  large=0.01
                nproduce StartGC() SetContour(limbo) SetWidth(large)RollR(0)Left(curve)SetColor(2)F(LSTEP)EndGC()
            
            if(X.id_rang==1 and X.id_talle>0):
              if (i>(X.TailleEmergence-2)/LSTEP):
                if large<=0:
                  large=0.01
                nproduce StartGC() SetContour(limbo) SetWidth(large)RollR(0)Left(curve)SetColor(2)F(LSTEP)EndGC()
              
              if (i<(X.TailleEmergence-2)/LSTEP): 
                rank=X.id_rang
                if(i<(10/LSTEP)):
                  if large<=0:
                    large=0.01
                  nproduce  StartGC() SetContour(foldlimbo) SetWidth(large)SetColor(2)Down(Torsiongaine*pow(-1,rank))F(LSTEP)EndGC()
                else:
                  if large<=0:
                    large=0.01
                  nproduce StartGC()SetContour(foldlimbo)SetWidth(large)SetColor(2)F(LSTEP)EndGC()
            
            else:
              if X.id_rang>4:
                pseudotige=max([Taille_finale_gaine[X.id_plante][X.id_talle][x] for x in xrange(X.id_rang-3,X.id_rang-1)])
              else:
                pseudotige=Taille_finale_gaine[X.id_plante][X.id_talle][X.id_rang-1]
              
              if ( i > pseudotige/LSTEP ):
                if i<numstepsg:
                  if X.Cutstatus=='entierementcoupee':
                    large_temp=max((2/pi)*(paramManagement['CoefDirLonLarAjust']*log(max(X.Taillegaine*5,1))-paramManagement['OrdOriLonLarAjust']),0.1)
                    if large_temp<=0:
                      large_temp=0.01
                    nproduce SetWidth(large_temp)SetContour(gaino)StartGC()SetColor(2)F(LSTEP)EndGC()
                  else:
                    if large<=0:
                      large=0.01
                    nproduce StartGC() SetContour(limbo) SetWidth(large)RollR(0)Left(curve)SetColor(2)F(LSTEP)EndGC()
                
                else:
                  if large<=0:
                    large=0.01
                  nproduce StartGC() SetContour(limbo) SetWidth(large)RollR(0)Left(curve)SetColor(2)F(LSTEP)EndGC()
              
              if (i<pseudotige/LSTEP):
                rank=X.id_rang
                if(i<(10/LSTEP)):
                  if large<=0:
                    large=0.01
                  nproduce  StartGC() SetContour(foldlimbo) SetWidth(large)SetColor(2)Down(Torsiongaine*pow(-1,rank))F(LSTEP)EndGC()
                else:
                  if large<=0:
                    large=0.01
                  nproduce StartGC()SetContour(foldlimbo)SetWidth(large)SetColor(2)F(LSTEP)EndGC()
          # Pour avoir feuille courbee et "s'ouvre" que quand en dehors de la gaine precedente la plus grande
          else:
            if (X.age>Agesenesc and X.age<=Agesenesc+50):                  # IMPOSSIBLE
              #print("limite senescence")
              if large<=0:
                large=0.01
              nproduce StartGC() SetContour(limbo) SetWidth(large)Left(curve)SetColor(2)F(LSTEP)EndGC()
      produce


SegFeuille(X):
  produce SetColor(10)F(1)


apex(X):
  nproduce StartGC() SetColor(3) F(0.2) EndGC()


ApexTal(X):
  nproduce StartGC() SetColor(5) F(0.2) EndGC()


EntrenoeudEpi(X):
  produce ;(5) F(X.long_entrenoeud)


Epillet(X):
  produce ;(6) F(X.long_epillet)


tip(X):
  if X.longueur<=0:
    nproduce StartGC()   SetColor(1)PglShape(Cone(X.diametre/2+0.2,0.1,True,16)) EndGC()
  else:
    nproduce StartGC()   SetColor(1)PglShape(Cone(X.diametre/2+0.2,X.longueur,True,16)) EndGC()

segment(X):
  nproduce StartGC() SetWidth(X.diametre/2+0.2)SetColor(1)F(X.longueur)EndGC()

endlsystem
###### INITIALISATION ######

__lpy_code_version__ = 1.1

def __initialiseContext__(context):
	context.options.setSelection('Module declaration',1)
	import openalea.plantgl.all as pgl
	profilelimbe = pgl.NurbsCurve2D(	
	    ctrlPointList = pgl.Point3Array([(-0.0864873, -1.28825, 1),(0.138172, -0.154037, 1),(0.134849, -0.160444, 1),(0.302985, -0.00246132, 1),(0.176901, 0.144132, 1),(0.149559, 0.150022, 1),(-0.0742404, 1.49117, 1)]) , 
	    )
	profilelimbe.name = "profilelimbe"
	profilefoldlimbe = pgl.NurbsCurve2D(	
	    ctrlPointList = pgl.Point3Array([(-0.202006, 0.250293, 1),(-0.262712, 0.243403, 1),(-0.285408, 0.179588, 1),(-0.166833, -0.0558834, 1),(0.238723, -0.168115, 1),(0.348058, 0.171371, 1),(0.33338, 0.337654, 1),(0.0711467, 0.435274, 1),(0.085187, 0.149124, 1),(0.0123227, 0.175151, 1)]) , 
	    )
	profilefoldlimbe.name = "profilefoldlimbe"
	profilegaine = pgl.NurbsCurve2D(	
	    ctrlPointList = pgl.Point3Array([(-0.407478, -0.0511938, 1),(-0.390245, -0.17963, 1),(-0.355, -0.3575, 1),(-0.0025, -0.4925, 1),(0.363333, -0.355, 1),(0.47, -5.58794e-009, 1),(0.349167, 0.3425, 1),(0.005, 0.455, 1),(-0.3275, 0.3625, 1),(-0.380592, 0.203264, 1),(-0.402904, 0.0550844, 1)]) , 
	    )
	profilegaine.name = "profilegaine"
	panel_0 = ({'active': True, 'visible': False, 'name': 'Curve2D'},[('Curve2D',profilelimbe),('Curve2D',profilefoldlimbe),('Curve2D',profilegaine)])
	panel_1 = ({'active': True, 'visible': False, 'name': 'Panel 2'},[])
	parameterset = [panel_0,panel_1,]
	context["__functions__"] = []
	context["__curves__"] = [('profilelimbe',profilelimbe),('profilefoldlimbe',profilefoldlimbe),('profilegaine',profilegaine),]
	context["__parameterset__"] = parameterset
	context["profilelimbe"] = profilelimbe
	context["profilefoldlimbe"] = profilefoldlimbe
	context["profilegaine"] = profilegaine
__references__ = '\n'
